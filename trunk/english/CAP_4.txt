CHAPTER 4: Interaction between programs and users on Amiga: GUI

"Neither PC, nor Mac, nor Amiga have invented the concept of mouse-driven
GUI, but in 1985 Amiga offered certainly its most interesting and complete
implementation."
Massimo Tantignone, "VisualPrefs and the Amiga GUI: tips and tricks", ??/01/2000 

"Design beautiful Gadgets, Menus, Requesters. Think simplicity and elegance. 
Always remember the fourth grader, the sophisticated user, and the poor 
soul who is terrified of breaking the machine. "
Robert J. Mical, Amiga Intuition Reference Manual

"In my opinion, neither a programmer nor the operating system shall 
define how GUI elements shall look. The only person who knows the best 
choice is the *user* of an application.
That's what MUI tries to accomplish. The *user* of a MUI application
can decide if he wants to have standard system scrollers or absolutely
fancy designed knobs sliding on a stony background pattern."
Stefan Stuntz, comp.sys.amiga.programmer, 13/08/1993

"[...]If you had read the MUI docs more carefully, you would have noticed that 
all MUI classes are subclasses of rootclass (since every BOOPSI object 
is a subclass of rootclass)[...]" 
"[...]Commodore implemented a gadget class and an image class (with several
sub classes) and instances of these (and only these) classes are
sometimes called by input.device.[...]"
"[...]MUI classes are not called by input.device and do not affect 
system performance![...]"
Stefan Stuntz, comp.sys.amiga.programmer, 04/09/1993   

"From a programmers point of view alone, MUI is heaven. Everything is so 
much easier than using gadtools. MUI isn't slow, either."
Hans-Joerg Frieden, comp.sys.amiga.programmer, 02/04/1994

"I like MUI for its configurability and ease of programming, and hence I use it.
[...]GadTools gadgets suck. The can't resize without being removed first, and
that something I don't like. Also, you have to control the keyboard, too,
which is in my opinion a waste. Additionally, most people use GadTools with
a hardcoded font and position, because gadtools (and even BOOPSI without a
layout engine) encourages fixed coordinates. There is no way to use the font-size
directly to position your gadgets.[...]
I do not like the MAGIC prefix, either. But then, I don't judge a program
by its name, or else I would consider the BOOPSI concept a VERY bad one."
Hans-Joerg Frieden, comp.sys.amiga.programmer, 11/04/1994

"[...]Its imperative for it (MUI) to be as *flexible* and as *extendable* as
 possible."
Stephan Stunz, comp.sys.amiga.programmer, 14/04/1994  


4.1 Tools to use to get a graphical interface on Amiga

A modern user application offers its features through the use of a
graphical interface. In practice, nowadays a "high level" programmer
(who develops programs without accessing low level resources) should
only use features offered by BOOPSI, using GadTools and Intuition
functions only if there are no viable high-level alternatives, such
ready to use BOOPSI classes. The use of functions GadTools or other
similar primitive entails a waste of energy for writing the code, and
the final result in many cases may not be consistent with the rest of the
Amiga graphics. In order to use BOOPSI, some concepts about object
oriented programming must be clear.



4.1.1 Pills of object oriented programming

This paragraph is addressed to those who have not familiarity with
object oriented programming, then who has already familiar with words
such instance, object, inheritance can directly go to next paragraph.

Object oriented programming is based on concepts like classes and
objects, which are very close to the way of thinking in human beings.

Consider for example the way in which man has classified the
living beings. We have for example animals, mammals, cats. A cat could
be Sylvester, your neighbour's cat. Sylvester is a cat which we refer in
particular, but if we talk about cats then we refer to a General family
of animals, in other words a "class" of animals. A class is a generic
entity which brings together the common characteristics, in our case we
know that cats have an age, the fur of a certain color and so on.
An object is a specific representation of a particular entity, in our case
we know that Sylvester is a black cat a year old. In other terms, Sylvester is
an "object". In a class we can identify structural and behavioural
characteristics, in the former case we refer to them with the "attributes" term,
while in the latter we talk about "methods". The attributes of a cat are its colour,
its age, etc, while the methods in a cat should be its active actions, such as
running, meowing and eating.
A class can be seen as the matrix from which a particular thing is generated: the
object. The process of generation of an object is called "instantiation", and so
an object is an instance of a class.

There are generic classes, such as mammals, and more specific classes, such as
the cat. Generally classes are developed following a hierarchy starting from
very generic classes to more specific classes, through a sort of relationship
that involves a definite group of classes. In our example we could say that the
"cat" class is the daughter of the "mammal" class.

The relationships between different classes are featured by a special
characteristic: a child class is provided with the characteristics of the
mother class, adding also new ones. This mechanism is called hierarchy. In our
case, for example, mammals have breasts and eat, characteristics inherited
from mammals, they also have whisker, claws and meows.

In object oriented programming, each class has two special methods, called
constructor and destructor. The constructor is usually the method that
initializes an object instanced from a class, while the destructor releases
the memory the object was using. There are also the so called setter and getter
functions, used to read and write object attribute values. Using getter and
setter functions the object oriented philosophy implements the encapsulation
concept: the need to protect internal data of a module, handling them through
special methods that check if inserted datas are correct. Obviously, getter
and setter methods would be used to their maximum if there were a system
to hide the attributes of a class from the outside. To this purpose, OOP
philosophy offers the chance to define such attributes as "private", that are
not directly accessible from the outside. Obviously, to private attributes
counteract "public" attributes, that is attributes accessible from outside.
Again, private attributes are not inherited by child classes.

During the process of inheritance, where classes daughters inherit methods by
upper classes, you can have problems of inconsistency. If we consider for
example the class of birds and on the daughter class  of the Penguins, the
latter in respect of rules of heredity will have its "fly" methods. As we know
the Penguins doesn't fly and this is a typical example of inconsistency
in the process of inheritance. To resolve this and other problems it's possible
to redefine the behavior of a method that the child class has inherited from
the mother class, this process is called method "overriding". In the exposed
example, the "fly" method called from a penguin object may have been
reimplemented in the penguin class in order to behave as if it were called a method
for swimming. Not all methods of a superclass must be inherited in the subclass,
there are in fact private methods, which can be used only by instances of class
in which they are. Inside a class other classes can be defined also, which can
be public or private, in the latter case we will have the same behavior described
for private attributes.

Finally several objects communicate with each other by exchanging
messages. A message in this case is the combination of a method to be
invoked and any values of the attributes that this method should
manipulate.

4.2. BOOPSI and MUI: some history

BOOPSI, Basic Object Oriented Programming System for Intuition, put the basis
for object oriented programming on AmigaOS. The BOOPSI system is developed
following a class hierarchy, which are related to a mother class: the
rootclass. BOOPSI, since its birth, have a little number of classes, a bit
extended with AmigaOS 3.0 (1992). Until then BOOPSI didn't have politics about
the layout of graphical objects nor many other classes for the users, also
some concepts about the interaction between classes and font handling were
quite laborious, and even the look that produced the classes was not the best.
While the small number of classes and the lack of policies for the positioning of
the elements in a window gave enormous freedom regarding the management of
the graphics application, not all were willing to support such an effort
for the creation of a graphical interface. For these reasons, in 1992 again,
starting from the rootclass, a new solution composed of classes was developed,
which solved a lot of the problems we have talked about, by adopting different
solutions than those proposed by the few BOOPSI official classes. Such new
classes were released with the name of "Magic User Interface", MUI was born.
During the years, and through the long wait for a new version of the operating
system, many programmers used MUI as an API for the development of their
applications, allowing the system to become increasingly robust, comprehensive
and versatile. Even if in 1995 there were new "pure" BOOPSI classes (ClassAct) -
in other words new classes extending the original BOOPSI system following the
philosophies of AmigaOS classes - MUI had been taken off the consent of 
Developers, and the number of applications written using ClassAct never 
exceeded those developer with MUI. This situation considerably slowed down the
development of new ClassAct classes and the debugging of the classes of that
distribution, while at the same period new third party MUI classes were born,
which offered many modern features to programmers, MUI "core" classes also 
became increasingly robust with the release of new versions of the distribution.
In 1999, a new AmigaOS version (3.5) was finally distributed. It officially
incorporated a new ClassAct version, called Reaction. However, even this try
to address developers to a more "pure" BOOPSI didn't led programmers to abandon
MUI. In 2001, with the release of AmigaOS 3.9 which included new Reaction
classes, MUI was choosen by MorphOS as its official API for graphical interfaces
and in 2002 MUI was reimplemented by AROS, and renamed Zune. In 2004, the
prerelease version of AmigaOS 4 was release, this operating system is equipped
both with new Reaction classes and with an OEM distribution of MUI, providing
the programmers with both solutions. At the end, although Reaction classes
have been greatly improved and developed in recent times, they are not available
on AROS and MorphOS and have many gaps and bugs on AmigaOS3.x, they also not have
the same functionality and robustness of the corresponding MUI classes, and the
number of classes available to Reaction programmers is lower than the MUI classes.
That is why the choice for an Amiga programmer without specific needs is
required: MUI must be used.

4.3 BOOPSI programming

In the previous paragraph we said that all BOOPSI classes are related to a
single mother class called rootclass. The rootclass defines a set of methods,
some of them have to be implemented on the child classes. BOOPSI methods are
classified by an identifier, called MethoID. The "pure" BOOPSI methods,
declared in <intuition/classusr.h>, that we will consider now are:

- OM_NEW: constructor;
- OM_DISPOSE: destructor;
- OM_SET: setter method;
- OM_GET: getter method;

Each MethodID has a prefix, OM on the four listed methods, which stands for
"ObjectMethod". As we know, the object oriented philosophy requires that
interaction with an object is made through messages. A BOOPSI message, called
"Object Packet", is made by the MethodID of the method to invoke and by the
parameters it accepts. For example, the object packet of the OM_NEW and OM_SET
methods is the following structure (defined in <intuition/classusr.h>):

struct opSet{

  STACKED ULONG MethodID;
  
  STACKED struct TagItem *ops_AttrList;
  
  STACKED struct GadgetInfo *ops_GInfo; 
}

The first element of the structure is the MethodID, the second is a pointer to
a list of attributes and corresponding values to assign to, while the last
member is not useful for our guide, we only need to know that it must be set to
NULL in our examples.

As we just said, the second element of the opSet message is a pointer to a list,
but what is the TagItem structure? A TagItem, or more shortly tag, is a couple
of values defined in <utility/tagitem.h> in this way:

struct TagItem {
  STACKED ULONG ti_Tag;  /* Tag identifier, in other words the name      */ 
                         /* of the object's attribute;          */
           
  STACKIPTR ti_Data;     /* The value to assign to the tag, 
                         /* that is the value to assign to the object's attribute;*/
}


However, is very common to handle with more tag at the same time, for this reason
they are saved in an array, called tag list.

In practice, an application sends a message to an object using the AmigaOS 
function called DoMethodA(), or its variation DoMethod().

Such functions are declared in <clib/intuition_protos.h> on OS4, and are called
IDoMethodA() and IDoMethod(), while in all other amiga oses their declarations
are in <clib/alib_protos.h>. However, on OS4 these functions can be called
using the "old" name without the "I" prefix.

If, for example, we want to modify an object attribute, we should write:

struct TagItem taglist[] = {{Attribute_ID, Attribute_Value},{TAG_END,0}};
struct opSet msg = {OM_SET,taglist,NULL};
DoMethodA (object, (Msg)&msg);

In the first row we created a tagList made by two tags, the first is the
attribute we want to modify, the second tag is a control attribute, in other
words we tell the system that the taglist is over. In this case we can use
both TAG_END or TAG_DONE. in the second row we build the actual BOOPSI message,
made by the MethodID, by the attribute/value list to assign and by the third
member of opSet that, as we said, must be set to NULL in our case. In the third
row we only send the message to our object. There is a shorter method to do this,
using the DoMethodA() variation called DoMethod():

struct TagItem taglist[] = {{Attribute_ID, Attribute_Value},{TAG_END,0}};
DoMethod(object, OM_SET, taglist, NULL);

This method is quite laborious and its use is not recommended in practice. There
intuition's functions that are made to call these BOOPSI methods, doing the
right initializations. Such methods are:

- NewObject()     : calls OM_NEW;
- DisposeObject() : calls OM_DISPOSE;
- SetAttrs()      : calls OM_SET;
- GetAttrs()      : calls OM_GET;

Let's modify the last example:

struct TagItem taglist[] = {{Attribute_ID, Attribute_Value},{TAG_END,0}};
DoMethod(object, OM_SET, taglist, NULL);

it becomes:

SetAttrs(object, Attribute_ID, Attribute_Value, TAG_END);

The calling of such functions requires the passage of tag in the argument list
of the function itself, this passing way is called "varargs": a function is
varargs when it accepts a variable number of arguments.

Handling variable parameters in C language requires accurate rules,
(http://publications.gbdirect.co.uk/c_book/chapter9/stdarg.html) which
affect the API of all the incarnation of AmigaOS, so we'll deepen this
topic later. (SDI_stdarg.h) 

Not all methods explained at the start of this paragraph can be applied to
every attribute of an object, there are some not configurable, not readable
and not initializable attributes. To indicate the applicability of a
method on an attribute some flags are included in the documentation of a
boopsi class:

- I: If present, the attribute is manipulable by OM_NEW;
- S: If present, the attribute is manipulable by OM_SET;
- G: If present, the attribute is manipulable by OM_GET;

There are other flags that we've not considered, which refer to methods that
we have still not examinated.


4.3.1 Instantiating a BOOPSI class

As you surely have intuited from the previous paragraph, we must use the
Intuition function NewObject() to instantiate a boopsi class, its declaration
is the following:

APTR NewObject(struct IClass *privateclass, 
           UBYTE *publicclassID, 
           unsigned long tag1, ...);

The reading of the first two parameters should confuse who have never used
Amiga, so it's better to introduce private and public BOOPSI classes. A
private class in BOOPSI is a class without a name, but a simple ASCII value.
A private class is *mostly* created by the user to be used only in his
application, while a public class is associated with an ASCII name and so
can also be accessible by other applications beyond one that contains the
declaration and implementation.

Let's return to the NewObject() function, if we pass NULL to the first
parameter, the function will realize that it must create an instance of a
public class, and for this reason it will ask the name of this class as
an ASCII value in the second parameter. Viceversa, if we want to instantiate
a private class, we have to pass a pointer to the private class to instantiate
as first parameter in NewObject(), we will deal with this case later.
NewObject is variable arguments function, in fact the second parameter
accepts a tag list, which is built "on the fly" on the stack, following
the varargs funcions rules. The NewObject() function returns a pointer to
the instantiated object, or NULL if something went wrong. So, if we have a
class whose ASCII name is "WindowPUB", with a "Title" attribute whose type is
STRPTR (pointer to string), we will have something like this:

Object *objWin; /* Declare a window object ;*/
objWin = (Object *) NewObject(NULL, "WindowPUB", 
                   Title, "This is a Window", 
                  TAG_DONE); 

We will do the following to release the memory used by this boopsi object:

DisposeObject(objWin);
 
The original BOOPSI project stated that for every call to the constructor
of a class there is sooner or later a call to the destructor
of the same class. However, with the new classes, manual calls to every
class destructor are very rare: if a class allow to connect other objects
to its instance (see the following chapter), the calling to the
DisposeObject() function of that class instance will recall the destructor
for every object connected to that instance. In other words, we will have
a cascade deallocation.


4.3.2 BOOPSI: adding an object to another object

In the previous chapter we mentioned some BOOPSI object that allow to
be connected to other objects. It's probably better to talk about objects
contained by other objects. The "containment" is another type of hierarchical
relationship in the latest BOOPSI releases, where the contained object becomes,
in some manner, "child" of its container. If, for example, we want a window
with buttons inside, we simply have to instantiate a window object and some
button objects and add these to the just instantiated window object. So, the
button objects are somehow childs of the window object. This is, in other terms,
more a logic relationship than phisics. The handling of the containment in
BOOPSI is committed to two methods of the rootclass:

- OM_ADDMEMBER: add an object to another object;
- OM_REMMEMBER: removes a specific object from another object;

For example, if we want to add a button object objBut (public class "ButtonPUB"
with a "Label" attribute) to the window object objWin we will do the following:

Object *objBut; /* we declare a button object  */
objBut = (Object *) NewObject(NULL, "ButtonPUB", 
                Label, "Push me!", 
                  TAG_DONE);
                   
DoMethod(objWin, OM_ADDMEMBER, objBut); 

Otherwise, if we want to remove that button from the window:

DoMethod(objWin, OM_REMMEMBER, objBut); 

In this last case we must take care during the release of the resources, because
after disconnecting an object from another we obviously must call explicitly
DiposeObject() on the disconnected child object, otherwise the memory will not
be released:

DisposeObject(objBut);


4.4 From BOOPSI to MUI 

Adding objects to another objects would be an useless feature if such objects
don't supply functions to the user. A user would not like to press a button
without obtaining some results. Following the OOP programming, an object
could interact with another through an exchange of messages, or in other
conditions, the handling of an object by an user could lead to the execution
of one or more methods. In all these cases we talk about "event notification".
The notify handling on "pure" BOOPSI is quite particular: we must involve two
methods from the rootclass called OM_UPDATE e OM_MODIFY, we must instantiate two
child classes of the rootclass called icclass e modelclass and, at the end, we 
must use the ICA_TARGET and ICA_MAP attributes of these two classes. Moreover,
there are other implementation details to follow that make this work a bit
laborious. Moreover, if we want to program following the standard OOP, so
developing with sub classes, "pure" BOOPSI forces to a number of arrangements
to follow that lead the programmers' efforts to the graphical interface instead
of the application itself.  
Another important thing when you uses a "pure"
BOOPSI programming it's given by difficults to implement GUIs which follow
Multiple Document Interface philosophy (MDI), which is based many ways on the
add and remove of graphical objects on the fly. This lack of "pure" BOOPSI
programming will force you to implementation of GUIs based on multiple
windows, a philosophy very diffused in the middle of '90 ages. 
Another problem not easly solvable with "pure" BOOPSI programming is object 
managment focus, more precisely when many graphical objects want to control 
shortcuts from keyboard in the same GUI. Behaviour of "pure" BOOPSI assigns 
all inputs to object focused, so if this object doesn't provide any support 
for a kind of shortcut, this one will be not managed. In other words on "pure" 
BOOPSI is absent input inheritance between objects. In the end on "pure" BOOPSI
programming is absent drag&drop support between graphical objects of a GUI,
and so you can't implement a GUI where user can set as he wants GUI
dragging and dropping UI components into windows of your program (like it
happens on Firefox UI). Sure you can write from scratch this kind of thing into 
your "pure" BOOPSI application, but it's not easy and it taken you too much time... 
Luckily the Amiga universe offers a solution to all
there problems: the using of the Amiga Users' most loved and hated GUI, in other
words: MUI.


4.4.1 MUI: overview

As we already mentioned, MUI is a collection of classes, which are linked
following a complex hierarchy that starts from the Notify and Semaphores MUI
classes, both childs of the rootclass. By now, we will focus only on the Notify
class and all its subclasses. The Notify class implements a new mechanism for
the notify of the events, which is inherithed by all its subclasses, following
OOP rules. Classes we are talking about are reported in the following simple
graph:

 rootclass                    
 +--Notify                  
 !  +--Family                
 !  !  *
 !  !      
 !  +--Application
 !  !           
 !  +--Window               
 !  !  * 
 !  !        
 !  +--Area                 
 !  !  +--Group
 !  !  *  *

Family is a generic class whose instances are able to keep objects
containing other objects. In other words, an instance of Family could
contain some Menu objects, that could contain other menu voices or
other menus as well.
Application is a class whose instance represents an application that
runs on the system, which can have a variable number of windows (Window
class instances).

Finally, the Area class is the mother of all other MUI gadgets and handles
all their informations, such as their dimensions, their look and their
positions. The Area class handles user inputs too. It's important to notice
that Area doesn't set the position of the elements inside one of its instances,
because Area is a generic class which can be user to build more complex gadgets.
Layout handling is performed by a child class of Area, called Group.
Theorically, all these classes should have a direct relationship, in other
words, Area should be child of Window, which should be child of Application
which should be child of Family. The author of MUI says that a direct
relationship between these classes wasn't possible to implement, due to some
BOOPSI limits. By the way, an instance of Application can contain one or
more instances of Window, some for Family-->Application and Window-->Area,
partially solving the non-phisical relationship problem.

Each MUI class is identified by a name preceded by "MUIC_" string, a class
attribute is identified by the "MUIA_" prefix, a method is identified by
the "MUIM_" prefix and so on... All the BOOPSI rules we talked about regarding
the methods of the rootclass are valid on MUI too, even if this set of API
provides the programmer with an alternative way for the object instantiation
and destruction. So it's possibile to use muimaster.library's MUI_NewObject()
and MUI_DisposeObject() methods instead of NewObject() and DisposeObject(),
we compare their use using, for example, the MUIC_Window class:

objWin = (Object *) NewObject(MUI_GetClass(MUIC_Window), NULL, 
                                  MUIA_Window_Title, "This is a Window", 
                              TAG_DONE);
            
Becomes:            
            
objWin = (Object *) MUI_NewObject(MUIC_Window, 
                                      MUIA_Window_Title, "This is a window", 
                                  TAG_DONE); 
            
Firse of all, we notice that in the first case that any MUI class is seen
as a BOOPSI private class. The instantiation occurs after getting the
pointer to the MUI class using the MUI_GetClass() method. Such procedure can
be problematic sometimes, in fact MUI_GetClass() keeps opened the class we are
looking for a pointer of, until the FreeClass() function get called, so
distraction errors could generate errors in the code. MUI_NewObject() solves
the problems of MUI class opening and closing, so a single use of a call to
DisposeObject() or MUI_DisposeObject() allows to put the system into initial
status. Again, if MUI_NewObject() will not be able to instance an object
containing more object previously instanced, it will deallocate these
objects.


4.4.2 MUI: An example of a simple graphical interface

Let's try to build a simple graphical interface with mui, we want to get
a window with a string as first element, and a button beneath it as second
element. Using mui classes we will have the following situation regarding
the button:


Object *button= MUI_MakeObject(MUIO_Button, "Click me!");

As you can see, we don't instantiate an object from a class, but we
get an object from a so called "prebuilt object". We talked about how
the Area class handle user input, this class can react to to some input
in a variety of ways, such as reacting like it was a button, or something
totally different. This is why MUI doesn't have a generic button class,
in fact on MUI a button is an instance of the MUIC_Text class with a border
as attribute and an assigned behaviour to react to the release of a mouse or
keyboard button. In such way, it's very simple to create more complex
gadgets, but it should be awkward to build a simple button. For this reason,
MUI provides pre built objects, ready for use. These objects are identified
by the "MUIO_" prefix. The MUI_MakeObject() function takes a prebuilt object
as first parameter, and its optional parameters, that aren't a tag list
(so there isn't TAG_END or TAG_DONE as last parameter). This is how we
instantiate a String from the MUIC_String class:


Object *string = MUI_NewObject(MUIC_String, 
                                    MUIA_Frame, MUIV_Frame_String, 
                                    MUIA_String_Contents, (IPTR) "Click on the button...", 
                                TAG_DONE);
      
Please notice the MUIA_Frame attribute that allows to define the border
in which our string will be put.

As we mentioned, to delegate to MUI the gadget layout we must use the MUIC_Group
class:

          
Object *group = MUI_NewObject(MUIC_Group,
                                   MUIA_Group_Child, string,
                                   MUIA_Group_Child, button,
                               TAG_DONE);

The default layout puts all the objects joined to an instance of MUIC_Group in
the same column, in which the first inserted element will be the first element
at the top of the column. To change the layout we must work on the attributes
provided by the MUIC_Group class, we recomend you to read the relative documentation.

At the end, we can instantiate our window:

Object *window = MUI_NewObject(MUIC_Window,
                                     MUIA_Window_Title, "My Window",
                                     MUIA_Window_ID ,MAKE_ID('M','a','i','n'),
                                     MUIA_Window_RootObject, group,
                                 TAG_DONE);

In this last instantiation process we can notice the MUIA_Window_ID attribute,
which allows the system to identify the window with an ID (using the MAKE_ID()
macro our characters will be condensed in an ULONG. This macro is in
<libraries/iffparse.h>). This attribute is important if the user wish to save,
for example, the size of the program window, everything will be done in a
transparent way from the programmer view.
We must take care of the is the MUIA_Window_RootObject attribute. It says what
the windows is going to contain (in other words, his child), usually a group,
if you need to display multiple gadgets. A MUIC_Window object can have only one
child.

As we previoulsy sayd, we must assign a MUIC_Application object to our window:


Object *app = MUI_NewObject(MUIC_Application,
                                MUIA_Application_Title  , "ShInKy Tutoral GUI",
                                MUIA_Application_Base  , "ShInKyTutorialGUI",
                                MUIA_Application_Description, "MUI GUI Example",
                                MUIA_Application_Window, window,
                            TAG_DONE);

MUIA_Application_Title is used by the system as application name, which will
be displayed to the user, while MUIA_Application_Base is the name used by
the system to identify the application. MUIA_Application_Description is the
description the system will give to the user about our application.
Now you can make the window visible (in other words, to open it) setting the
MUIA_Window_Open attribute to TRUE, in this way:

SetAttrs(window, MUIA_Window_Open, TRUE, TAG_DONE);

We must say that a MUIC_Window object exists only in the context of a
MUIC_Application object, this means that you cannot make your window visible
until you add it to your application object, otherwise you will get a crash.

We started the building of this graphical interface from the innermost element,
to the outermost, having care to avoid passing a NULL pointer to the just
exposed MUIA_Group_Child, MUIA_Window_RootObject and MUIA_Application_Window
attributes. It's time to go back to the rootclass' OM_ADDMEMBER method we
have previously described (4.3.2), which allows us to build our interface as
follows:


Object *app = MUI_NewObject(MUIC_Application,
                                MUIA_Application_Title  , "ShInKyButton",
                                MUIA_Application_Base  , "ShInKyButton",
                            TAG_DONE);

Object *group = MUI_NewObject(MUIC_Group, TAG_DONE);


Object *string = MUI_NewObject(MUIC_String, 
                                    MUIA_Frame, MUIV_Frame_String,
                                    MUIA_String_Contents,(IPTR) "Press the button...",
                                TAG_DONE);
        
Object *button= MUI_MakeObject(MUIO_Button, "Cliccami!");

DoMethod(group, OM_ADDMEMBER, string);
DoMethod(group, OM_ADDMEMBER, button);


Object *window = MUI_NewObject(MUIC_Window,
                                     MUIA_Window_Title, "My Window",
                                     MUIA_Window_ID ,MAKE_ID('M','a','i','n'),
                                     MUIA_Window_RootObject, group,
                                 TAG_DONE);


DoMethod(app, OM_ADDMEMBER, window);

With this method we can add child objects to other objects
after their instantiation. If we want, for example, to remove our window
from app object, we have to follow these steps:

SetAttrs(window, MUIA_Window_Open, FALSE, TAG_DONE); /*close the window;*/

DoMethod(app, OM_REMMEMBER, window); /*remove the window object       */
                                       /*from the application object;          */

If we want to add new MUIC_Group objects to a window we must close it first,
while if we want to add or remove objects from a MUIC_Group instance, we must
explicitly notify these actions to MUI. To do this, we must surround the code
in which we will perform the removal or addition of elements in the group
through the use of the MUIM_Group_InitChange method, notifying the end of the
changes invoking the MUIM_Group_ExitChange method:

DoMethod(group, MUIM_Group_InitChange);
.
.
.
/*changes*/
.
.
.
DoMethod(group, MUIM_Group_ExitChange);


Feel free to choose the creation and removal method, following your needs.

4.5 MUI: Notifications

In 4.4 we talked about the notification concept. A graphical object can
react to an user action, performing an action that can involve other
graphical objects. Following the example in the previous paragraph, we now
want the content of the string and the button to change when we right click
on the button. To obtain this, MUI uses the MUIM_Notify method of the
class with the same name, and since almost alla MUI classes are child of
MUIC_Notify, all our instances can use the MUI notification system.
MUIM_Notify method can be used using three different techniques: an AmigaOS
standard called "callback hook", notification through methods inside our
private classes, or using notificable attributes. For now, we will deal with
the first technique, we will see the other (more OOP compliants) later.


4.5.1 MUI: Notifications with callback hook

The philosophy under the callback hook involve the extension of a module
(a library, a device, a class, etc...) through the hooking of new
functions. To obtain this, a new function is hooked to a module using a
structure called Hook. The Hook structure is different in the various
AmigaOS flavours, so to keep compatibility, we will use the SDI tools
(see Chap 1), specifically an header called SDI_hook.h. In practice,
using SDI_hook.h, we can build the function to hook and its relative hook
in this way:

/*Function to hook*/
HOOKPROTO(NameOfTheFunction, 
          ReturnValue,
          ObjectToHandle,
          ParametersToReceive);
{
....
}
/*Hook to be used*/
MakeHook(HookName, NameOfTheFunction);

SDI_hook.h allows us to choose between different ways to create functions
and to create hooks, we suggest the reading of this header for further details.

Following the example in the previous paragraph, we first write the hookPutVal()
function, able to perform the change of the attributes of the button and string
objects, then we write the relative Hook called buttonHook:

HOOKPROTONO(hookPutVal, void, APTR *data)
{

  Object *button, *string;
  
  button=(Object *) *data++;
  string=(Object *) *data++; 
    
  SetAttrs(string, 
           MUIA_String_Contents,
           (IPTR) "Button clicked!",
           TAG_DONE);
     
  SetAttrs(button, 
           MUIA_Text_Contents,
           (IPTR) "Clicked!",
           TAG_DONE);
     
  SetAttrs(button, 
           MUIA_Disabled,
           TRUE,
           TAG_DONE);

      
}
MakeStaticHook(buttonHook,hookPutVal);  

As you can see in the function declaration, we are using the "NO" variant
provided by SDI_hook.h, that allows us to avoid using the parameter
regarding the object to manipulate, in fact in this case we are dealing
with two objects. These objects are passed by address, more precisely the
"data" variable contains the parameters received by the calling program,
whose first parameter passed with data is the hook address. To obtain
the address of the first object passed to the function after the hook, we
shift a position in memory (*data++), in this new position the system
have put the address of the first object. We proceed in this way for the
following objects too, in this case we have only a button and a string.
At this point, we got all the data we need to handle mui objects:
we then proceed to three calls to SetAttrs(), the first allow us to put
the "Button clicked!" text inside out MUIC_String object, the second 
changes the text inside the button, the third makes the button disabled.
The hooking of the function to an object is made with the MUIM_CallHook
method, addressed by MUIM_Notify:

DoMethod(button,  MUIM_Notify, 
                  MUIA_Pressed, FALSE,
                  MUIV_Notify_Self,
                  4,
                  MUIM_CallHook,
                  &buttonHook,
                  button,
                  string);

Using DoMethod() we call the MUIM_Notify method, that allows to bind a
notification to an object. This method takes the following parameters:

- the object that will activate a notification;
- the attribute of the object to control in order to activate a notification;
- the object on which the notification method will be executed;
- the number of parameters passed to the notification method;
- the notification method;

In our example:

- MUIM_Notify is called on our button;
- MUIA_Pressed is checked to be FALSE, that is the release of the button after
  being pressed;
- The notification method must be applied on the button itself (MUIV_Notify_Self);
- The number of parameters for the notification method: 4;
- Notification method: MUIM_CallHook;

To be honest, the 4 number tells how much parameters are found after
the MUIV_Notify_Self value. Obviously, who writes the function for the hook
must know the number of parameters will be passed from DoMethod() to the
hook function, otherwise he will lead to disasters with the pointer operations
we previously explained.

The applicability of the notification method, in our case MUIM_CallHook, is
ruled by MUIM_Notify through a predeclared value in the mui system. Generally,
a mui value is identified by the "MUIV_" prefix, in the MUIV_Notify case we
can choose from:

- MUIV_Notify_Self: the object itself on which the MUIM_Notify method is called;
- MUIV_Notify_Window: the MUIC_Window instance that contains the object;
- MUIV_Notify_Application: the MUIC_Application instance that contains the object's
  mother window;
- MUIV_Notify_Parent: the object's parent instance;

The MUIM_CallHook method calls a hook function through the relative hook,
in our case we have buttonHook as our hook, whose hooked function hookPutVal()
receives button and string as parameters.

4.5.2 MUI: closing window and the old notify method with ReturnID

Even the application closing using the close gadget at the top of the
window is handled with the MUIM_Notify method. Following the example in
the previous paragraph, our window object is handled as following:


DoMethod(window, MUIM_Notify, 
                   MUIA_Window_CloseRequest, TRUE,
                   MUIV_Notify_Application,
                   2,
                   MUIM_Application_ReturnID,
                   MUIV_Application_ReturnID_Quit);

This time we are telling the system that then the MUIA_Window_CloseRequester
attribute turns TRUE (so the user clicked the close window gadget), on the
MUIC_Application (MUIV_NotifyApplication) the window object relates to, it
must execute the MUIM_Application_ReturnID method, passing the
MUIV_Application_ReturnID_Quit value to it.

MUIM_Application_ReturnID is a method that "forces" the MUIM_Application_(New)Input
method to return a return value, in our case the next call to MUIM_Application_Input
will return MUIV_Application_ReturnID_Quit.

MUIM_Application_Input is a method, now obsolete, used to catch all the
return values associated to user inputs on a MUI application. This involved
the use of a big control cycle, in which every return value of a MUI interface
were checked. This technique is the same of the "pure" BOOPSI programming and
assigns the input controlling to the application itself. Even if in some
situations, using Reaction classes, this kind of handling can be avoided, on
"pure" BOOPSI a big control cicle is the standard way of handling with inputs.
MUI keeps a similar method for backward compatibility with older applications and
only to handle the close gadget of the window. More precisely, 
a faster version of MUIM_ApplicationInput is used for this goal, called
MUIM_Application_NewInput; In practice, we will have the call to
MUIM_Application_ReturnID with:

IPTR sigs = 0;
while (DoMethod(app,MUIM_Application_NewInput,(IPTR)&sigs) != MUIV_Application_ReturnID_Quit)
{
  ;
}

Basically we check that MUIM_Application_NewInput returns in the sigs variable
a value different from MUIV_Application_ReturnID_Quit. Otherwise the while
loop would exit, allowing the application to follow closing operations. Is a
common practice to add a control for the interrupt signal CTRL+C inside that
while loop, in order to have the closing of the application when it's launched
from the command line (Shell) with the CTRL+C keys.

while (DoMethod(app,MUIM_Application_NewInput,(IPTR)&sigs) != MUIV_Application_ReturnID_Quit)
{
  if (sigs)
  {
    sigs = Wait(sigs | SIGBREAKF_CTRL_C);
    if (sigs & SIGBREAKF_CTRL_C) break;
  }
}

To learn about the Wait() function and the SIGBREAKF_CTRL_C see paragraph 5.1


4.5.3 Zune and MUIM_Application_Execute

In the previous paragraph we described a while loop to check for the application
closing, usually called "main loop".
Zune offers the programmer the chance to not declaring a main loop, leaving the
closing task to a new method, MUIM_Application_Execute. Basically this method
hides the use of the main loop from the programmer, making everything look more
readable and modern. Its syntax is simply:

DoMethod(app, MUIM_Application_Execute);

We let to the reader the implementation of a portable MUIM_Application_Execute.
Informations useful for such implementation will be explained later.


4.6 Il cuore di una classe BOOPSI/MUI: il Dispatcher

Finora ci siamo limitati ad istanziare classi già a nostra disposizione, 
senza sapere come crearne di proprie. La programmazione orientata agli 
oggetti ha come scopo quello di rendere le applicazioni che ne fanno uso 
altamente modulari. Seguendo le regole della programmazione ad oggetti 
si ottengono inoltre dei moduli riutilizzabili in contesti differenti, e 
la programmazione MUI non è un'eccezione. 

What we have done until now is to instantiate classes which system gives us, without to know how we can create our ones. One of pourpose of Object Oriented Programming is to make applications which uses this philosophy highly modular. Following OOP rules it's possible to obtain reusable modules in different contexts, and MUI isn't an exception.

Innanzitutto il motore che rende una classe BOOPSI (e MUI) un modulo 
attivo è una particolare funzione chiamata dispatcher. Nel momento in 
cui un oggetto BOOPSI riceve un messaggio, quest'ultimo viene 
controllato dalla funzione dispatcher, la quale verifica se è in grado 
di trattare i parametri ricevuti attraverso il messaggio. In altre 
parole tutte le funzioni di Intuition e MUI che abbiamo visto fin'ora 
richiamano la funzione dispatcher, difatti un oggetto BOOPSI è solo una 
struttura dati tipica del linguaggio C, la quale non potrebbe mai 
svolgere un'azione senza l'intervento del dispatcher. 

First of all heart which makes a BOOPSI (and MUI) class an active module is a particular function called dispatcher. When a BOOPSI object receives a message, this last one is checked by dispatcher function, which verify if it is able to manipulate received parameters into the message. This means all Intuition and MUI functions which we have seen until now call their dispatcher functions, in fact a BOOPSI object is only a typical C data struct, which could never execute something without execution of dispatcher function.

Come sappiamo ciascuna classe BOOPSI è figlia di un'altra classe, tale 
relazione di parentela si articola sino ad arrivare alla rootclass. 
Ciascuna classe possiede una propria funzione di dispatcher, la quale, 
nel caso in cui non dovesse riconoscere un parametro ricevuto, avrebbe 
il compito di inviare tale parametro sconosciuto al dispatcher della 
classe madre. Questo "rimbalzo" verso l'alto di parametri potrebbe 
arrivare sino al dispatcher della rootclass, il quale nel caso in cui 
non riconoscesse uno dei parametri ricevuti risponderebbe al messaggio 
con un codice d'errore. 

How we know, each BOOPSI class is children of another class, this kindship is divided up to arrive to rootclass. Each class has a own dispatcher function, which, in case it wasn't able to know a received parameter, it should send that unknown parameter to dispatcher function of parent class. This "bounce" upward of parameters could arrive up to rootclass dispatcher, which reply to that message with an error code in case of unknown kind of received parameter.


In altri termini il dispatcher è la funzione che richiama i metodi della 
classe a cui appartiene, scegliendo quale metodo eseguire dall'analisi 
del messaggio ricevuto. Il dispatcher potrebbe implementare al suo 
interno i metodi della classe in casi semplici, o richiamare altre 
funzioni che corrisponderebbero in tal modo ai metodi stessi della 
classe. Anche la dichiarazione e la definizione di un dispatcher varia 
da un'incarnazione all'altra di AmigaOS, per fortuna gli SDI Tools ci 
vengono nuovamente in aiuto con due nuove macro, residenti sempre in 
SDI_hook.h, chiamate DISPATCHERPROTO() e DISPATCHER(). DISPATCHERPROTO() 
è la macro usata per dichiarare il prototipo del dispatcher, accetta un 
unico argomento, il quale è semplicemente il nome del nostro dispatcher: 

So a dispatcher is a function which calls methods of membership class, choosing one of methods analizing received message. In simple cases dispatcher could implement into itself class methods, or to call   other functions which correspond theirself in this case to class methods. Even declaration and definition of a dispatcher function changes from an AmigaOS flavour to another one, but using SDI Tools give us two new macros, which are declared into  SDI_hook.h: DISPATCHERPROTO() and DISPATCHER().
DISPATCHERPROTO() is the macro used to declared dispatcher prototype, it accepts an olny one argument, which is simply the name of our dispatcher:

DISPATCHERPROTO(MyDispatcher);

Con la macro DISPATCHER() invece definiamo la funzione vera e propria:

With DISPATCHER() macro we difined instead the real function:

DISPATCHER(MyDispatcher)
{
  switch (msg->MethodID)
  {
    case OM_NEW : return myNew(cl,obj,(APTR)msg);
  }

  return DoSuperMethodA(cl,obj,msg);
}

In questo esempio il dispatcher si occupa di gestire solamente il metodo 
della propria classe OM_NEW, impiegando con questo scopo una funzione chiamata 
mioNew(), della quale ci occuperemo in seguito. 
Dopo aver gestito, eventualmente, OM_NEW, il dispatcher passa quindi il messaggio 
alla classe madre, utilizzando la funzione DoSuperMethodA() di 
Intuition. I parametri cl, obj e msg, sono stati ricevuti dal dispatcher 
stesso, difatti il prototipo di un dispatcher per ciascun sistema 
prevede comunque l'inserimento di questi tre argomenti: cl è la classe 
cui appartiene il dispatcher, obj è l'oggetto che ha ricevuto il 
messaggio, msg è il messaggio, nel nostro caso opSet (vedi paragrafo 
4.3). 

In this example dispatcher check only OM_NEW method of its class, using with this purpose a function called myNew(), we will describe it into next paragraphs.
After to have check and eventually managed the OM_NEW, our dispatcher sends received message to parent class, using with this reason DoSuperMethodA() Intuition function. Parameters cl, obj, and msg were received from dispatcher itself, in fact a dispatcher prototype for each AmigaOS flavour provides in any case to insert these three arguments: cl is the class which belongs our dispatcher, obj is the object which has received that message, in our case an opSet (see 4.3 paragraph).



4.6.1 Implementazione di una classe MUI privata

La potenza della programmazione ad oggetti è il poter creare delle
classi proprie da riutilizzare in casi differenti. Se ad esempio 
volessimo creare una sottoclasse di MUIM_Group, contenente i due oggetti 
bottone e stringa del paragrafo 4.5 dovremmo innanzitutto dichiarare 
l'area dati della nostra nuova classe, la quale è una semplice 
struttura: 

struct miaAreaDati
{    
   Object *bottone, *stringa;
   STRPTR labelButton, labelStr;
};

A questo punto secondo le regole BOOPSI le variabili dichiarate in 
questo modo all'interno dell'area dati saranno riconosciute, in seguito, 
come attributi privati della classe. 

Sebbene una classe mui preveda la possibile implementazione dei seguenti 
metodi: 


- OM_NEW;
--- MUIM_Setup;
--- MUIM_AskMinMax;
------ MUIM_Show;
--------- MUIM_Draw;
------ MUIM_Hide;
--- MUIM_Cleanup;
- OM_DISPOSE;

Ciascun metodo dovrà essere implementato solo nel caso ci fosse la reale 
necessità. Per la documentazione di ciascun metodo rimandiamo alla 
documentazione MUI presente all'interno dell'archivio muidevXX.lha, al 
momento ci occuperemo solo di implementare il metodo OM_NEW. 


4.6.2 Implementazione del metodo OM_NEW e dei tag esterni

Considerando l'esempio del dispatcher del paragrafo 4.5.2, la
possibile definizione di una funzione mioNew() che corrisponderà al metodo OM_NEW 
è la seguente: 


IPTR mioNew(struct IClass *cl,Object *obj,struct opSet *msg)
{
  struct miaAreaDati *data;
  .
  .
  .
  .
  /*chiamata al metodo OM_NEW della superclasse*/
  .
  .
  .

  data = INST_DATA(cl,obj);
  
  .
  .
  .
  .
  /*ritorno il puntatore all'oggetto istanziato*/
    
}

La funzione incaricata di essere OM_NEW avrà sempre questa forma per ciò 
che concerne i suoi parametri: cl è la classe a cui appartiene il 
dispatcher, obj è l'oggetto che ha ricevuto il messaggio, msg è il 
messaggio ricevuto. INST_DATA() è una macro di sistema utilizzata per 
ricavare l'indirizzo iniziale dell'area dati dell'oggetto chiamante.

L'area dati della nostra classe non è nient'altro che la composizione
dell'area dati da noi dichiarata, contenente le altre aree dati delle
eventuali superclassi (polimorfismo). L'allocazione delle altre aree dati
viene effettuata richiamando il metodo OM_NEW della superclasse, il quale
invocherà il metodo OM_NEW della sua superclasse, e cosivvia fino ad arrivare
alla rootclass. Il metodo OM_NEW della rootclass allocherà a questo punto memoria
sufficiente per un'area dati appartenente ad una propria istanza, passandola
poi alla sottoclasse attraverso un puntatore: è stata così creata un'istanza
della rootclass. La sottoclasse, ricevuto l'oggetto rootclass impiegherà quindi
la macro INST_DATA() per dire al sistema di allocare altra memoria da aggiungere
all'area dati della superclasse (identificata attraverso il puntatore all'oggetto
di rootclass), in modo da popolarla con la propria aera dati.
A questo punto, dopo aver svolto eventualmente altre azioni, il metodo OM_NEW di
tale classe passerà questa nuova area dati "composta" alla sottoclasse, sempre
attraverso un puntatore all'oggetto istanziato. Questo processo viene svolto da
ciascuna superclasse, sino a giungere al nostro metodo OM_NEW, il quale non farà
altro che mimare i su indicati passi, impiegando a tale proposito la macro
INST_DATA().

Prima della chiamata al metodo OM_NEW della superclasse, potremmo voler leggere
eventuali parametri passati dall'esterno (un messaggio) al nostro metodo.
Nel nostro esempio, nel caso in cui si volessero inizializzare da OM_NEW i
valori di labelButton e labelStr, bisognerà innanzitutto effettuare un'associazione
logica tra tali variabili e delle etichette (ID) che il metodo OM_NEW riconoscerà. Per
dichiarare degli ID si procede come segue:

#define MUI_CLASS_TUTORIAL (TAG_USER | 0x80420000)
#define MUIA_MUIClassTutorial_TextStr MUI_CLASS_TUTORIAL + 1
#define MUIA_MUIClassTutorial_LabelBut MUI_CLASS_TUTORIAL + 2

Abbiamo definito tre simboli, gli ultimi due dipendono dal primo. 
MUI_CLASS_TUTORIAL è il simbolo di partenza da cui generiamo gli altri 
due, il suo valore è dato da TAG_USER (un valore di sistema impiegato 
per distinguere i tag utente da quelli di sistema) combinato con il 
valore esadecimale 0x80420000 attraverso un OR bitwise. La scelta del 
valore esadecimale non è casuale, difatti la documentazione mui 
raccomanda di usare valori esadecimali compresi tra 0x80420000 e 
0x80429999 per le variabili pubbliche delle proprie classi. 

In realtà nel caso in cui dovessimo creare solo classi private, e cioè
non accessibili da altri programmi fuorchè il nostro, potremmo definire 
i simboli per i nostri attributi e metodi in tal modo:

#define MUIA_MUIClassTutorial_TextStr  TAG_USER + 20
#define MUIA_MUIClassTutorial_LabelBut TAG_USER + 21

Ed a seguire... tenendo a mente di utilizzare dei valori per i nostri
simboli abbastanza distanti rispetto al valore TAG_USER, altrimenti
potremmo riscontrare delle anomalie in alcune situazioni.

A questo punto dovremo analizzare il messaggio ricevuto, controllando se
l'utente ha inviato eventuali inizializzazioni per labelButton e labelString.
Si procede quindi in questi termini:

Object *stringa, *bottone;    /*allochiamo gli oggetti che popoleranno
STRPTR labelStr, labelButton;   in seguito la nostra area dati*/

{/*blocco per la lettura della tag list*/
  struct TagItem *tags, *tag;

  tags=((struct opSet *)msg)->ops_AttrList;
  while (tag=NextTagItem(&tags))
  {
    switch (tag->ti_Tag)
    {
      case MUIA_MUIClassTutorial_TextStr:
      if (tag->ti_Data)
        labelStr= (STRPTR) tag->ti_Data;
      break;
      
      case MUIA_MUIClassTutorial_LabelBut:
      if (tag->ti_Data)
        labelButton= (STRPTR) tag->ti_Data;
      break;
    }
  }
}

Come sappiamo il messaggio opSet (paragrafo 4.3) possiede una 
variabile chiamata ops_AttrList che punta alla tag list passata, per 
tale motivo abbiamo dichiarato due puntatori tags e tag, utilizzati 
entrambi con la funzione NextTagItem() della utility.library. Tale 
funzione richiede l'indirizzo di una tag list, ed è utilizzata per 
scorrere la tag list stessa. Ogni nuova chiamata a NextTagItem() 
rappresenta lo scorrimento di una posizione in avanti nella tag list, e 
tale spostamento si riflette sulla tag list passata. Il valore di 
ritorno di NextTagItem() è il tag corrente sul quale la tag list passata 
risiede. Con lo switch controlliamo il valore tag->ti_Tag del tag 
corrente, nel caso in cui corrispondesse ad uno dei simboli 
precedentemente stabiliti verrà svolta un'azione: se tag->Ti_Tag è 
uguale a MUIA_MUIClassTutorial_TextStr allora verrà inizializzato 
labelStr con il valore residente in tag->ti_Data, mentre labelButton 
verrà inizializzato a tag->Data se tag->ti_Tag sarà uguale a 
MUIA_MUIClassTutorial_LabelBut. 

E' bene notare come la dichiarazione di NextTagItem() su AROS sia leggermente
differente dalle altre incarnazioni Amiga, per tale motivo il su indicato
codice comporterebbe degli avvisi (warnings) da parte del compilatore.
Per risolvere questa situazione è possibile usare la macro TAGLIST:

#ifdef __AROS__
  #define TAGITEM const struct TagItem **
#else
  #define TAGITEM  struct TagItem **
#endif  

ed effettuare il seguente casting:

...
 while (tag=NextTagItem((TAGITEM)&tags))
...

E' prassi comune utilizzare una simile sintassi con NextTagItem(), switch e case nel
caso in cui venga implementato il metodo OM_SET e nel caso in cui ci
fossero molti attributi da gestire. E' possibile sintetizzare tale scrittura
impiegando a questo proposito la funzione GetTagData() della utility.library:

IPTR GetTagData(Tag,IPTR,struct TagItem *);

La funzione vuole l'etichetta del tag da individuare come primo argomento, 
un valore di ritorno di default nel caso in cui non venga trovata l'etichetta 
come secondo argomento, e la già vista ops_AttrList come ultimo argomento. 
Impiegando GetTagData() al nostro esempio avremo:

struct TagItem *tags;
tags=((struct opSet *)msg)->ops_AttrList;

labelStr= (STRPTR) GetTagData(MUIA_MUIClassTutorial_TextSt, (IPTR)NULL,tags);
      
labelButton= (STRPTR) GetTagData(MUIA_MUIClassTutorial_LabelBut, (IPTR)NULL,tags);      
 
Abbiamo già accennato di possibili attributi non gestiti dal metodo 
OM_NEW della classe corrente. Un attributo in questa 
situazione dovrebbe essere gestito nel nostro esempio dall'analogo 
OM_SET della classe madre, il quale verrà chiamato anche per risolvere
questa situazione.

A questo punto bisognerà istanziare, come svolto in precedenza (paragrafo 4.4.2),
gli oggetti stringa e bottone, inizializzandoli con i valori di
labelStr e labelButton.

Per richiamare adesso il metodo OM_NEW della superclasse
si può utilizzare DoSuperMethodA(), o la sua versione varargs DoSuperMethod(),
in questo modo:

struct TagItem taglist[] = {{MUIA_Group_Child, (IPTR) stringa},
                            {MUIA_Group_Child,(IPTR) bottone},
                            {TAG_MORE, (IPTR) msg->ops_AttrList}};
            
obj =(Object *) DoSuperMethod(cl, 
                              obj,
                              OM_NEW,
                              taglist,
                              NULL);
            
if (obj==NULL)
  return 0;

Attraverso DoSuperMethod() abbiamo chiamato il metodo OM_NEW della classe
madre, nel nostro esempio è MUIC_Group, passando ad esso una tag list che 
permetterà al metodo chiamato di creare un gruppo con la nostra
stringa e il nostro bottone come figli. TAG_MORE segnala al sistema la 
presenza di una nuova tag list, il cui puntatore, come sappiamo, si 
trova in msg->ops_AttrList. Se DoSuperMethod() ritorna NULL significa 
che gli argomenti passati non sono stati riconosciuti dalla classe 
madre. Questa scrittura è tuttavia un pò ostica, per tale motivo è 
prassi comune utilizzare una funzione di utilità chiamata DoSuperNew(). 
Approfondiremo l'analisi di DoSuperNew() in un secondo momento, per ora 
riporteremo la semplice chiamata a questa funzione per sostituire le 
righe su indicate: 

obj = DoSuperNew(cl, 
                 obj,
                 MUIA_Group_Child, stringa,
                 MUIA_Group_Child, bottone,
                 TAG_MORE, msg->ops_AttrList);

if (obj==NULL)
  return 0;

Con DoSuperNew() abbiamo passato al metodo OM_NEW della classe madre, 
nel nostro caso MUIC_Group, gli oggetti stringa e bottone, i quali 
diventeranno dunque i figli del prossimo oggetto che istanzieremo 
dalla nostra nuova classe. Gli oggetti stringa e bottone saranno dunque 
posizionati automaticamente all'interno di un oggetto MUIC_Group, ed 
insieme a esso rappresenteranno ciò che sarà un'istanza della nostra 
classe mui privata.
Adesso non ci rimane altro da fare che chiamare la macro INST_DATA(),
con la quale ricaveremo la nostra area dati, quest'ultima verrà così
popolata:

data = INST_DATA(cl,obj);

data->labelStr    = labelStr;
data->labelButton = labelButton;
data->stringa     = stringa;
data->bottone     = bottone;

return obj;

A questo punto in sostanza abbiamo esposto tutto ciò che ci serve per
implementare il metodo OM_NEW.


4.6.3 Utilizzo di una classe privata

Dopo aver implementato tutto ciò che ci occorre nei paragrafi 
precedenti, siamo nelle condizioni di utilizzare la nostra nuova classe 
mui. Per ottenere tutto questo dobbiamo renderla disponibile al nostro 
programma attraverso la funzione MUI_CreateCustomClass() di 
muimaster.library. La sintassi è nel nostro caso la seguente: 

struct MUI_CustomClass *mcc;

mcc = (struct MUI_CustomClass *) MUI_CreateCustomClass(NULL,
                                                       MUIC_Group,
                                                       NULL,
                                                       sizeof(struct miaAreaDati),
                                                       ENTRY(MioDispatcher));
                   
Il primo parametro di questa funzione va a NULL per ciò che concerne le 
classi mui private, viene impiegato infatti nel caso in cui si stia 
rendendo disponibile in memoria una classe mui pubblica, al momento non 
ci interessa sapere altro. Il secondo parametro rappresenta la classe 
madre della nostra classe privata, dalla quale erediterà i relativi 
metodi ed attributi. Il terzo metodo viene usato solo nel caso in cui la 
nostra sottoclasse sia figlia di un'altra classe privata e dunque nel 
nostro caso va anch'esso a NULL. Il quarto parametro dev'essere la 
dimensione dell'area dati della nostra classe, l'ultimo parametro 
dovrebbe essere il nome della funzione dispatcher. La macro ENTRY(), 
presente nelle SDI, viene utilizzata da MorphOS per distinguere una 
classe nativa ppc da una classe 68k, i compilatori degli altri sistemi 
invece la ignorano. In questo modo possiamo rendere compatibile la nostra 
classe anche con MorphOS. 

A questo punto, se la funzione MUI_CreateCustomClass() ha avuto 
successo, all'interno della variabile mcc avremo un puntatore alla 
nostra classe mui privata, da utilizzare con la funzione NewObject() di 
Intuition in questo modo: 

Object *MyObj; 

MyObj = (Object *) NewObject(mcc->mcc_Class, 
                             NULL,
                             MUIA_MUIClassTutorial_TextStr,(IPTR) "Clicca il bottone...",
                             MUIA_MUIClassTutorial_LabelBut,(IPTR) "Cliccami!",
                             TAG_DONE);

Come potete notare dall'esempio, una classe mui privata è identificata 
attraverso la struttura MUI_CustomClass, la quale contiene un puntatore 
(mcc_Class) ad una struttura IClass, con la quale vengono identificate 
le classi BOOPSI private. La documentazione raccomanda solo in questo 
caso di non utilizzare la funzione MUI_NewObject(). Con NewObject() come 
sappiamo stiamo chiamando il metodo OM_NEW della nostra classe, al quale 
passiamo i valori per gli attributi MUIA_MUIClassTutorial_TextStr e 
MUIA_MUIClassTutorial_LabelBut. 

Dopo aver utilizzato la nostra classe, dovremmo cancellarla dalla 
memoria con la funzione: 

MUI_DeleteCustomClass(mcc);

la cui chiamata va dopo la canonica MUI_DisposeObject(); 

Dunque, inserendo la chiamata a MUI_CreateCustomClass() in un'apposita funzione,
il nostro codice è così completo:

/****************************************************************************/
//file sys.h
/****************************************************************************/
/* Includes */
#ifndef __SYS_INCLUDES__
#define __SYS_INCLUDES__

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <proto/exec.h>
#include <proto/dos.h>
#include <proto/utility.h>
#include <proto/intuition.h>

#include <proto/muimaster.h>
#include <libraries/mui.h>

#if !defined (__amigaos4__)
#include <clib/alib_protos.h>
#endif
                
#include <SDI_compiler.h>
#include <SDI_hook.h>
#include <SDI_stdarg.h>


#if !defined(__AROS__) || !defined(__MORPHOS__)
#ifdef __amigaos4__
#define IPTR uint32
#else
#define IPTR ULONG
#endif
#endif

#ifndef __AROS__
#define STACKED
#endif

#ifdef __AROS__
    #define TAGITEM const struct TagItem **
#else
    #define TAGITEM  struct TagItem **
#endif

#if !defined (__MORPHOS__)
Object * VARARGS68K DoSuperNew(struct IClass *cl, Object *obj, ...);
#endif

#endif   
         
/****************************************************************************/

/****************************************************************************/
// file MUIClass.h
/****************************************************************************/

#ifndef __MYMUICLASS__
    #define __MYMUICLASS__

    #define MUI_CLASS_TUTORIAL (TAG_USER | 0x80420000<<16)

    #define MUIA_MUIClassTutorial_TextStr MUI_CLASS_TUTORIAL + 1
    #define MUIA_MUIClassTutorial_LabelBut MUI_CLASS_TUTORIAL + 2

    struct MUI_CustomClass *initMUIClass();
#endif    
/****************************************************************************/

/****************************************************************************/
//file MUIClass.c
/***************************************************************************/

#include "sys.h"
#include "MUIClass.h"

struct MyData
{
    Object *button, *str;
    STRPTR labelButton, labelStr;
};


///hookPutVal
HOOKPROTONO(hookPutVal, void,APTR *data)
{
    Object *bt_1, *str;
        
    bt_1=(Object *) *data++;
    str=(Object *) *data++; 
                
    SetAttrs(str, MUIA_String_Contents,(IPTR) "Bottone Cliccato", TAG_DONE);
    SetAttrs(bt_1, MUIA_Text_Contents,(IPTR) "Cliccato!", TAG_DONE);
    SetAttrs(bt_1, MUIA_Disabled,TRUE, TAG_DONE);    
}
MakeStaticHook(buttonHook, hookPutVal);
///

///OM_NEW()
IPTR mNew(struct IClass *cl,Object *obj,struct opSet *msg)
{
    struct MyData *data;
        
    STRPTR labelStr, labelButton;
    Object *str, *button;
    struct TagItem *tags;

    tags=((struct opSet *)msg)->ops_AttrList;

    labelStr= (STRPTR) GetTagData(MUIA_MUIClassTutorial_TextStr, (IPTR)" ",tags);

    labelButton= (STRPTR) GetTagData(MUIA_MUIClassTutorial_LabelBut, (IPTR)" ",tags);

        
    str = MUI_NewObject(MUIC_String,
                            MUIA_Frame, MUIV_Frame_String,
                            MUIA_String_Contents,(IPTR) labelStr,
                        TAG_DONE);
        
    button= (Object *) MUI_MakeObject(MUIO_Button,(IPTR) labelButton, TAG_DONE);
                                        
    obj = (Object *) DoSuperNew(cl, obj,
                                    MUIA_Group_Child, str,
                                    MUIA_Group_Child, button,
                                TAG_MORE, msg->ops_AttrList);

    if (obj==NULL)
        return 0;

    data = (struct MyData *) INST_DATA(cl,obj);

    data->str= str;
    data->button=  button;
    data->labelStr= labelStr;
    data->labelButton=  labelButton;

    DoMethod(data->button, MUIM_Notify,
             MUIA_Pressed, FALSE,
             MUIV_Notify_Self, 4,
             MUIM_CallHook,
             &buttonHook,
             data->button,
             data->str);
                         
    return (IPTR)obj;
}
///

///MyDispatcher
DISPATCHER(MyDispatcher)
{
    switch (msg->MethodID)
    {
        case OM_NEW : 
            return mNew(cl,obj,(struct opSet *)msg);
    }

    return(DoSuperMethodA(cl,obj,msg));
}
///

struct MUI_CustomClass *initMUIClass()
{
    return (MUI_CreateCustomClass(NULL, MUIC_Group, NULL, sizeof(struct MyData), ENTRY(MyDispatcher)));
}
                                                                                                 
/****************************************************************************/

/****************************************************************************/
//file main.c
/****************************************************************************/
#include "sys.h"
#include "MUIClass.h"

#ifdef __MORPHOS__
    struct Library *UtilityBase;
#else
    struct UtilityBase *UtilityBase;
#endif

struct IntuitionBase *IntuitionBase;
struct Library *MUIMasterBase;

#ifdef __amigaos4__
    struct UtilityIFace *IUtility;
    struct IntuitionIFace *IIntuition;
    struct MUIMasterIFace *IMUIMaster;
#endif

struct MUI_CustomClass *mcc;

///fail()
void fail(Object *app, STRPTR avviso)
{
    struct EasyStruct requester;
        
    if (app)
        MUI_DisposeObject(app);

#ifdef __amigaos4__
    if (IMUIMaster)
        DropInterface((struct Interface *)IMUIMaster);
        
    if (IIntuition)
        DropInterface((struct Interface *)IIntuition);
        
    if (IUtility)
        DropInterface((struct Interface *)IUtility);
#endif

    if (MUIMasterBase)
        CloseLibrary((struct Library *)MUIMasterBase);

    if (IntuitionBase)
        CloseLibrary((struct Library *)IntuitionBase);

    if (UtilityBase)
        CloseLibrary((struct Library *)UtilityBase);


    requester.es_StructSize = sizeof(struct EasyStruct);
    requester.es_Flags      = 0;
        
    if (avviso != NULL)
    {
        requester.es_Title        =  "Startup Error";
        requester.es_TextFormat =  avviso;
        requester.es_GadgetFormat =  "Exit";
        EasyRequestArgs(NULL, &requester, NULL, NULL);
    }
    else
    {
        requester.es_Title        = "Avviso";
        requester.es_TextFormat =  "Chiusura eseguita con successo";
        requester.es_GadgetFormat = "Exit";
        EasyRequestArgs(NULL, &requester, NULL, NULL);
    }
}
///

///init()
void init(void)
{
        #ifdef __MORPHOS__
    if ( !(UtilityBase=(struct Library *) OpenLibrary("utility.library",39)) )
        #else
    if ( !(UtilityBase=(struct UtilityBase *) OpenLibrary("utility.library",39)) )
        #endif
    {
        fail(NULL, "Attenzione! Non è stato possibile\n aprire utility.library");
    }
    else
    {
        #ifdef __amigaos4__
        IUtility = (struct UtilityIFace *) GetInterface((struct Library *)UtilityBase, 
                                "main", 
                                1, 
                                NULL);
        #endif        
    }

    if ( !(IntuitionBase=(struct IntuitionBase *) OpenLibrary("intuition.library",39)) )
    {
        fail(NULL, "Attenzione! Non è stato possibile\n aprire intuition.library");
    }
    else
    {
        #ifdef __amigaos4__
        IIntuition = (struct IntuitionIFace *) GetInterface((struct Library *)IntuitionBase, 
                                        "main", 
                                        1, 
                                        NULL);
        #endif        
    }

    if (!(MUIMasterBase = OpenLibrary(MUIMASTER_NAME,19)))
    {
        fail(NULL,"Attenzione! Non è stato possibile\n aprire muimaster.library" );
    }
    else
    {
        #ifdef __amigaos4__
        IMUIMaster = (struct MUIMasterIFace *) GetInterface(MUIMasterBase, 
                                        "main", 
                                        1, 
                                        NULL);
        #endif        
    }    
}
///

///Funzione main()                             
int main(int argc,char *argv[])
{
    Object *MyObj, *window, *app;
    

    init();

    if (!(mcc = (struct MUI_CustomClass *) initMUIClass()))
    {
                        fail(NULL,"Non è stato possibile creare la classe...");
    }


    MyObj = (Object *) NewObject(mcc->mcc_Class, NULL,
                                    MUIA_MUIClassTutorial_TextStr,(ULONG) "Clicca il bottone...",
                                    MUIA_MUIClassTutorial_LabelBut,(ULONG) "Cliccami!",
                                 TAG_DONE);


    window = (Object *) MUI_NewObject(MUIC_Window,
                                        MUIA_Window_Title,(IPTR) "Mia Finestra",
                                        MUIA_Window_ID ,MAKE_ID('M','a','i','n'),
                                        MUIA_Window_RootObject, (IPTR) MyObj,
                                      TAG_DONE);
                                        

        app = (Object *) MUI_NewObject(MUIC_Application,
                                        MUIA_Application_Title      ,(IPTR)  "MuiPortableClass",
                                        MUIA_Application_Version    ,(IPTR)  "$VER: MuiPortableClass 1.0",
                                        MUIA_Application_Copyright  ,(IPTR)  " ",
                                        MUIA_Application_Author     ,(IPTR)  "ShInKurO",
                                        MUIA_Application_Description,(IPTR)  "Classe MUI portabile",
                                        MUIA_Application_Base       ,(IPTR)  "MuiPortableClass",
                                        MUIA_Application_Window, (IPTR) window,
                                       TAG_DONE);
                                        
     

    if (!app)
        fail(app, "Non è stato possibile creare l'applicazione");

    DoMethod(window, 
                MUIM_Notify,
                MUIA_Window_CloseRequest,
                TRUE,
                app,
                2,
                MUIM_Application_ReturnID,
                MUIV_Application_ReturnID_Quit);

    
    SetAttrs(window, MUIA_Window_Open, TRUE, TAG_DONE);
                
    {/*blocco per la chiusura del programma*/
        IPTR sigs = 0;
        while (DoMethod(app,MUIM_Application_NewInput,&sigs) != MUIV_Application_ReturnID_Quit)
        {
            if (sigs)
            {
                sigs = Wait(sigs | SIGBREAKF_CTRL_C);
                if (sigs & SIGBREAKF_CTRL_C) break;
            }
        }
    }

    SetAttrs(window, MUIA_Window_Open,FALSE,TAG_DONE);


    DisposeObject(app);     
    MUI_DeleteCustomClass(mcc);
    fail(NULL, NULL);          

    return 0;
}
///  
/****************************************************************************/


4.7 DoSuperNew() e le funzioni varargs

DoSuperNew() appartiene alle funzioni di utilità di MorphOS e permette 
di semplificare la creazione dei metodi di nuove sottoclassi BOOPSI e 
MUI. Ovviamente come da tradizione in queste situazioni, DoSuperNew() 
non è presente negli altri sistemi, ma gli stessi autori degli SDI Tools 
hanno indirettamente messo a disposizione una versione di questa 
funzione che impiega tali headers. L'implementazione è la seguente, ed 
utilizza gli header SDI_stdarg.h ed SDI_compiler.h da includere nella 
compilazione: 


Object * VARARGS68K DoSuperNew(struct IClass *cl, Object *obj, ...)
{
  Object *rc;
  VA_LIST args;

  VA_START(args, obj);
  rc = (Object *)DoSuperMethod(cl, obj, OM_NEW, VA_ARG(args, IPTR), NULL);
  VA_END(args);

  return rc;
} 

La macro VARARGS68K presente nella dichiarazione della funzione nasce su 
AmigaOS4, e serve per indicare al compilatore per OS4 di gestire i 
parametri variabili della funzione come avverrebbe su AmigaOS3.x. Gli 
altri compilatori grazie a SDI_compiler.h riescono invece ad ignorare la 
macro VARARGS68K. Le macro VA_LIST, VA_START(), VA_ARG() e VA_END() 
corrispondono alle omonime va_list, va_start(), va_arg() e va_end() 
della libreria stdarg.h e sono state "reinplementate" in SDI_stdarg.h in 
modo tale da avere uno standard comune su tutti gli OS Amiga, i quali 
implementano in modo differente lo standard ANSI per le funzioni 
varargs. 


4.8 MUI: notifica mediante metodi pubblici di classi private

Dopo aver esposto i principali concetti per la creazione di una classe
privata possiamo adesso introdurre la seconda modalità per la gestione
della notificazione cha avevamo già accennato in precedenza (paragrafo
4.5). 
Innanzitutto è bene sottolineare come la precedente modalità di
notifica che impiega il sistema callback hook, in alcune situazioni, 
potrebbe non rispettare uno dei capisaldi della programmazione ad oggetti, 
ovverosia l'incapsulamento,basato sul concetto d'information hiding. 
In altre parole una classe dovrebbe essere una scatola nera dai contenuti 
non del tutto conosciuti,la quale fornisce dei servizi all'utente. Tuttavia 
attraverso l'utilizzo di un hook e di una funzione ad esso connessa è 
possibile modificare dall'esterno attributi di una classe considerati privati, 
passandoli semplicemente alla funzione di hook. L'utilizzo degli hook inoltre
prevede molte volte l'impiego dell'aritmetica dei puntatori, la quale
può fare incorrere ad errori di distrazioni. Per evitare delle
situazioni come questa e rispettare l'OOP è possibile gestire la
notificazione attraverso l'implementazione di metodi pubblici appartenenti alla 
nostra classe privata. Un metodo appartenente ad una classe ovviamente potrà
operare solo con l'area dati della classe (cioè con gli attributi della
classe stessa). E' bene inoltre ricordare come nel paradigma OOP un
metodo di una classe venga invocato attraverso un messaggio, nel caso di
BOOPSI e MUI sappiamo che un messaggio viene rappresentato da una
struttura contenente l'ID del metodo ed eventualmente i parametri da
passare a quest'ultimo. Riprendiamo adesso l'esempio del paragrafo
4.5.1, in cui avevamo una stringa, un bottone, e volevamo cambiare i
loro valori nel momento in cui l'utente avrebbe premuto il bottone.
Innanzitutto bisogna stabilire l'ID per il nostro nuovo metodo:

#define MUIM_MUIClassTutorial_ClickBut MUI_CLASS_TUTORIAL + 20

Passiamo adesso alla dichiarazione del messaggio:

struct MUIMP_MUIClassTutorial_ClickBut
{
  STACKED ULONG  MethodID;
};

in questo caso messaggio conterrà alla sua inizializzazione solo l'ID
del metodo, difatti nel nostro esempio non ci servono altri parametri,
in quanto il nostro metodo dovrà agire su dati interni alla classe. La
funzione che verrà associata al metodo MUIM_MUIClassTutorial_ClickBut
altro non è che una versione modificata della precedente funzione
hookPutVal. Più precisamente nel caso di callback hook avevamo:


HOOKPROTONO(hookPutVal, void, APTR *data)
{

  Object *bottone, *stringa;

  bottone=(Object *) *data++;
  stringa=(Object *) *data++;

  .
  .
  .

}
MakeStaticHook(buttonHook,hookPutVal);

invece adesso avremmo una funzione di questo genere:

IPTR mClickBut(struct IClass *cl,Object *obj, struct MUIMP_MUIClassTutorial_ClickBut *msg)
{

  struct MyData *data;
  data = (struct MyData *) INST_DATA(cl,obj);
  Object *bt_1, *str;

  bt_1=(Object *) data->button;
  str=(Object *)  data->str;

  .
  .
  .

  return (IPTR) obj;
}

Il confronto tra le due versioni è immediato: non abbiamo più un
utilizzo esplicito dell'aritmetica dei puntatori e la nostra funzione
appare come qualsiasi altra demandata allo scopo di metodo di una
classe. Il dispatcher della nostra classe privata assocerà a questo
punto la funzione mClickBut() all'ID MUIM_MUIClassTutorial_ClickBut:


DISPATCHER(MyDispatcher)
{
  switch (msg->MethodID)
  {
    case OM_NEW :
    return mNew(cl,obj,(struct opSet *)msg);

    case MUIM_MUIClassTutorial_ClickBut :
    return mClickBut(cl,obj,(struct MUIMP_MUIClassTutorial_ClickBut *)msg);
  }

  return(DoSuperMethodA(cl,obj,msg));
}

Fino ad ora abbiamo solamente dichiarato un nuovo metodo per la nostra
classe privata, senza connetterlo al sistema di notifica MUI. Per
ottenere tutto ciò dovremo utilizzare il già discusso metodo
MUIM_Notify, il quale nel caso del callback hook veniva così utilizzato:


DoMethod(bottone, MUIM_Notify,
                  MUIA_Pressed, FALSE,
                  MUIV_Notify_Self,
                  4,
                  MUIM_CallHook,
                  &buttonHook,
                  bottone,
                  stringa);

mentre nel caso di notifica attraverso metodo avremo:

DoMethod(data->button, MUIM_Notify,
                   MUIA_Pressed, FALSE,
                   obj,
                   1,
                   MUIM_MUIClassTutorial_ClickBut);

In altre parole stiamo utilizzando DoMethod() per svolgere la seguente
azione: "Ogni qualvolta il bottone data->button viene selezionato invoca
sull'istanza (obj) della nostra classe privata il metodo
MUIM_MUIClassTutorial_ClickBut". Ecco il codice sostitutivo:

/*****************************************************************************/
// file MUIClass.h                             
/*****************************************************************************/

#ifndef __MYMUICLASS__
  #define __MYMUICLASS__

  #define MUI_CLASS_TUTORIAL (TAG_USER+20)

  #define MUIA_MUIClassTutorial_TextStr MUI_CLASS_TUTORIAL + 1
  #define MUIA_MUIClassTutorial_LabelBut MUI_CLASS_TUTORIAL + 2
  #define MUIA_MUIClassTutorial_App MUI_CLASS_TUTORIAL + 3

  struct MUIMP_MUIClassTutorial_ClickBut
  {
    STACKED ULONG MethodID;

  };


  #define MUIM_MUIClassTutorial_ClickBut MUI_CLASS_TUTORIAL + 20

  struct MUI_CustomClass  *initMUIClass();
#endif
/*****************************************************************************/

/*****************************************************************************/
//file MUIClass.c
/*****************************************************************************/
struct MyData
{
  Object *button, *str;
  STRPTR labelButton, labelStr;
};


///OM_NEW
static IPTR mNew(struct IClass *cl,Object *obj,struct opSet *msg)
{

  STRPTR labelStr, labelButton;
  Object *str, *button;
  struct TagItem *tags =((struct opSet *)msg)->ops_AttrList;
    
  labelStr= (STRPTR) GetTagData(MUIA_MUIClassTutorial_TextStr, (IPTR)" ",tags);

  labelButton= (STRPTR) GetTagData(MUIA_MUIClassTutorial_LabelBut, (IPTR)" ",tags);
      
  str = MUI_NewObject(MUIC_String,
                      MUIA_Frame, MUIV_Frame_String, 
                      MUIA_String_Contents,(IPTR) labelStr,
                      TAG_DONE);
    
  button= (Object *) MUI_MakeObject(MUIO_Button,(IPTR) labelButton, TAG_DONE);
                    
  obj = (Object *) DoSuperNew(cl, 
            obj,
            MUIA_Group_Child, str,
            MUIA_Group_Child, button,
            TAG_MORE, msg->ops_AttrList);

  if (obj==NULL)
    return 0;
    
  {
    struct MyData *data;
    data = (struct MyData *) INST_DATA(cl,obj);

    data->str = str;
    data->button = button;
    data->labelStr = labelStr;
    data->labelButton = labelButton;

    DoMethod(data->button, MUIM_Notify,
                           MUIA_Pressed, FALSE,
                           obj,
                           1,
                           MUIM_MUIClassTutorial_ClickBut);
  }


  return (IPTR)obj;
}
///

/// MUIM_MUIClassTutorial_ClickBut
static IPTR mClickBut(struct IClass *cl,Object *obj, struct MUIMP_MUIClassTutorial_ClickBut *msg)
{

  struct MyData *data;
  Object *bt_1, *str;

  data = (struct MyData *) INST_DATA(cl,obj);
  bt_1=(Object *) data->button;
  str=(Object *)  data->str;

 

  SetAttrs(str,  MUIA_String_Contents,(IPTR) "Bottone Cliccato", TAG_DONE);
  SetAttrs(bt_1, MUIA_Text_Contents,(IPTR) "Cliccato!", TAG_DONE);
  SetAttrs(bt_1, MUIA_Disabled,TRUE, TAG_DONE);
 
  return (IPTR) obj;
}
///

///MyDispatcher
DISPATCHER(MyDispatcher)
{
  switch (msg->MethodID)
  {
    case OM_NEW                         :    return mNew(cl,obj,(struct opSet *)msg);
    case MUIM_MUIClassTutorial_ClickBut :    return mClickBut(cl,obj,(struct MUIMP_MUIClassTutorial_ClickBut *)msg);
  }

  return(DoSuperMethodA(cl,obj,msg));
}
///

///initMUIClass()
struct MUI_CustomClass  *initMUIClass()
{
  return (struct MUI_CustomClass *) MUI_CreateCustomClass(NULL, MUIC_Group, NULL, sizeof(struct MyData), ENTRY(MyDispatcher));

}
///
/*****************************************************************************/

4.8.1 MUI: notifica mediante attributi notificabili

Abbiamo già incontrato una situazione in cui il cambiamento del valore 
di un attributo comporti l'esecuzione di una determinata azione. Nel 
nostro caso l'attributo era già fornito dalla classe MUI di supporto che 
avevamo usato, più precisamente ci riferiamo all'attributo MUIA_Pressed. 
Potremmo pensare a questo punto che il cambiamento del valore di ogni 
attributo fornito dalle classi MUI possa attivare una nostra funzione 
attraverso le regole in precedenza elencate, ma non è così. In realtà 
solo alcuni attributi di ciascuna classe MUI possono attivare un'azione 
ogni qualvolta il loro valore subisce un cambiamento. Innanzitutto 
formalizziamo un concetto che abbiamo sin'ora sottointeso: un attributo 
si dice "notificabile" se è possibile agganciare un'azione ad un 
eventuale cambiamento del suo valore. Come abbiamo accennato, non tutti 
gli attributi forniti dalle classi di MUI sono notificabili e, 
soprattutto, gli attributi delle nostre classi private non sono 
notificabili, a meno di non renderli tali. Esistono infatti delle regole 
da rispettare nel caso in cui volessimo rendere un attributo di una 
nostra classe privata notificabile, così da agganciare un'azione ad esso 
da altre nostre classi. A questo punto è bene elencare l'object packet 
(il messaggio) del metodo OM_GET: 

struct opGet
{
  STACKED ULONG  MethodID;      /*OM_GET                             */
  STACKED Tag    opg_AttrID;    /*attributo da leggere               */
  STACKED IPTR   *opg_Storage;  /*area di memoria che conterrà       */
                                /*il valore dell'attributo richiesto */ 
};
 
La gestione di questo messaggio da parte del metodo Get di una classe è 
molto semplice: la funzione adibita a metodo Get non farà altro che 
controllare in opg_AttrID se è presente l'ID di un attributo 
appartenente alla propria classe, se la risposta è affermativa allora la 
funzione utilizzerà l'area di memoria opg_Storage, memorizzando su essa 
il valore dell'attributo richiesto, infine la funzione ritornerà TRUE. 
Quest'ultimo valore, secondo le regole di BOOPSI, indica che 
l'operazione è andata a buon fine. Se invece opg_AttrID non conterrà 
alcun attributo la funzione adibita a metodo Get passerà come di 
consueto il messaggio alla sua superclasse. 

Abbiamo esposto i principali passi di OM_GET poiché la prima e più 
importante regola di MUI per ottenere un attributo notificabile è quella 
di renderlo leggibile dall'esterno, o meglio, se vogliamo usare un 
inglesismo, il nostro attributo dev'essere "gettabile". 

Ovviamente vogliamo che il nostro attributo inneschi una notifica solo 
nel caso in cui la scrittura del nuovo valore non sia uguale a quella 
che l'attributo aveva. In altre parole, se ad esempio il nostro 
attributo è TRUE, non vogliamo essere avvisati che il valore di 
quest'attributo stia di nuovo "cambiando" in TRUE. Per ottenere tutto 
questo basterà sovrascrivere, nel messaggio di OM_SET l'ID 
dell'attributo contenuto in ti_Tag con TAG_IGNORE. In questo modo 
eviteremo anche di ritrovarci in eventuali situazioni anomale. 

Abbiamo adesso tutti gli elementi teorici necessari per rendere un 
nostro attributo notificabile, non ci rimane altro da fare che visionare 
un esempio pratico. 

Supponiamo di avere tre nostre classi, le quali hanno tra loro una 
gerarchia: la Classe1 e la Classe2 sono conosciute dalla Classe3, ma tra 
di loro non hanno contatti e s'ignorano reciprocamente. Schematizzando 
avremo una situazione del genere: 

Classe1--->Classe3<---Classe2

Ciascuna classe ha una propria area dati, quest'ultima, per rispettare 
il concetto d'information hiding, è nota solo alla classe a cui 
appartiene. Supponiamo inoltre che ciascuna classe abbia dei propri 
attributi e metodi pubblici. Vogliamo a questo punto che nel momento in cui 
l'attributo MUIA_Classe1_Attr1 cambia il suo valore in TRUE allora la Classe2 
esegua il proprio metodo MUIM_Classe2_Metodo2. Innanzitutto avremo una 
situazione del genere per ciò che concerne la Classe1: 


*******************************************************************************
struct areaDati1
{
  LONG attr1;
  ....
};

*******************************************************************************
....
//metodo OM_GET
IPTR GetClasse1(struct IClass *cl,Object *obj,struct opGet *msg)
{
  struct areaDati1 *data = INST_DATA(cl, obj);

  switch (msg->opg_AttrID)
  {
    case MUIA_Classe1_Attr1:
      *msg->opg_Storage = (LONG) data->attr1;
      return TRUE;

    ...
  }

  return DoSuperMethodA(cl,obj,(Msg)msg);
}                                         
*******************************************************************************
...
//metodo OM_SET
IPTR SetClasse1(struct IClass *cl,Object *obj,struct opSet *msg)
{
  struct areaDati1  *data = INST_DATA(cl,obj);

  {/*blocco per la lettura della tag list*/
    struct TagItem *tags, *tag;
    tags=((struct opSet *)msg)->ops_AttrList;

    while (tag=NextTagItem((TAGITEM)&tags))
    {
      switch (tag->ti_Tag)
      {
        case MUIA_Classe1_Attr1:
         if (data->attr1==tag->ti_Data) tag->ti_Tag = TAG_IGNORE;
        else                                                                        
          data->attr1 = (LONG) tag->ti_Data;
        break;

        ...
      }
    }
  }

  return DoSuperMethodA(cl,obj,(Msg)msg);
}
....
 
*******************************************************************************

In questo modo l'attributo MUIA_Classe1_Attr1 notifica i propri 
cambiamenti dall'esterno della Classe1. Per attivare l'esecuzione del 
metodo MUIM_Classe2_Metodo2 supponiamo di aver istanziato all'interno 
della Classe3 due oggetti, uno dalla Classe1 e l'altro dalla Classe2: 


....

Object *obj1, *obj2;

obj1 = NewObject(Classe1->mcc_Class,  NULL, TAG_DONE);
obj2 = NewObject(Classe2->mcc_Class,  NULL, TAG_DONE);

....

A questo punto non dovremmo far altro che agganciare la nostra notifica 
come di consueto: 


DoMethod(obj1,  MUIM_Notify,
        MUIA_Classe1_Attr1, TRUE,
        obj2,
        1,
        MUIM_Classe2_Metodo2);



4.8.2 MUI: catene di notifiche

Nel paragrafo precedente abbiamo esposto come rendere notificabile un 
attributo di una nostra classe. Accade spesso di avere una gerarchia di 
classi in cui è importante per una classe in cima alla gerarchia 
conoscere il cambiamento di valore di un attributo appartenente ad 
un'altra classe in basso alla gerarchia. Più precisamente prendiamo in 
considerazione tre classi, la cui gerarchia è: 


Classe1-->Classe2-->Classe3

Classe3 non conosce l'esistenza della Classe1, poiché il nostro sistema 
rispetta l'incapsulamento e l'information hiding. La Classe2 ha un 
attributo, MUIA_Classe2_Attr2, il quale assume i valori di un altro 
attributo appartenente alla Classe1, MUIA_Classe1_Attr1. La Classe3 ha a 
sua volta un attributo MUIA_Classe3_Attr3 che assume i valori 
dell'attributo della Classe2 MUIA_Classe2_Attr2. In altre parole abbiamo 
una situazione in cui il cambiamento di valore dell'attributo 
MUIA_Classe1_Attr1 innesca una notifica che permette alla Classe2 di 
assegnare lo stesso valore di MUIA_Classe1_Attr1 al proprio attributo 
MUIA_Classe2_Attr2, e la stessa cosa accade per la Classe3 e 
MUIA_Classe3_Attr3. In questa situazione la Classe3 ha al suo interno 
un'istanza della Classe2, mentre la Classe2 ha al suo interno un'istanza 
della Classe1, in sostanza: 


MUIA_Classe1_Attr1 = MUIA_Classe2_Attr2 = MUIA_Classe3_Attr3

Per ottenere tutto questo dovremo innanzitutto scrivere per ciascuna 
classe i metodi OM_GET ed OM_SET come mostrato nel paragrafo precedente. 
A questo punto, detta istanza1 l'oggetto istanziato della Classe1 all'interno 
della Classe2, avremo bisogno, da qualche parte nella Classe2 (di solito 
all'interno del metodo OM_NEW) della seguente notifica: 


DoMethod(istanza1, MUIM_Notify,
           MUIA_Classe1_Attr1, MUIV_EveryTime,
           obj,
           3,
           MUIM_Set,
           MUIA_Classe2_Attr2,
           MUIV_TriggerValue);

MUIV_EveryTime è uno speciale valore MUI che suggerisce a questo sistema di 
catturare qualsiasi cambiamento valido (cioè una reale variazione del 
valore) eseguito sull'attributo MUIA_Classe1_Attr1. MUIM_Set altri non è 
se non il nostro solito metodo OM_SET opportunamente modificato: OM_SET 
come sappiamo richiede una taglist, ed un tale passaggio di parametri 
sarebbe piuttosto scomodo in questa situazione. Per tale motivo MUI offre 
il metodo MUIM_Set, il quale permette di passare i parametri senza l'ausilio 
di tag list, come del resto avviene in questo esempio. MUIV_TriggerValue è 
un altro valore speciale MUI che suggerisce a questo sistema di passare ad un 
dato metodo, nel nostro caso MUIM_Set, qualsiasi valore che è stato 
notificato per mezzo del valore MUIV_EveryTime. In sostanza MUI 
sostituisce MUIV_TriggerValue con il valore che ha innescato la 
notifica. 
Allo stesso modo ci comporteremo per MUIA_Classe2_Attr2 e 
MUIA_Classe3_Attr3, inserendo nella Classe3 la seguente notifica: 


DoMethod(istanza2, MUIM_Notify,
           MUIA_Classe2_Attr2, MUIV_EveryTime,
           obj,
           3,
           MUIM_Set,
           MUIA_Classe3_Attr3,
           MUIV_TriggerValue);

A questo punto ogni qualvolta varierà il valore MUIA_Classe1_Attr1, tale 
cambiamento si rifletterà anche su MUIA_Classe2_Attr2 e 
MUIA_Classe3_Attr3. 

Per concludere possiamo adesso implementare in una terza maniera l'esempio 
del paragrafo 4.5.1, senza l'ausilio di hooks o nuovi metodi della 
classe da definire. Avremo bisogno solamente di tre notifiche, più 
precisamente nell'esempio del paragrafo 4.5.1 avevamo un bottone, una stringa 
e tre attributi che variavano al cambiamento di valore di MUIA_Pressed. 
Possiamo ottenere tutto questo come segue: 


DoMethod(bottone, MUIM_Notify,
          MUIA_Pressed, FALSE,
          stringa,
          3,
          MUIM_Set,
          MUIA_String_Contents,
          "Bottone Cliccato");  

DoMethod(bottone, MUIM_Notify,
          MUIA_Pressed, FALSE,
          bottone,
          3,
          MUIM_Set,
          MUIA_Text_Contents,
          "Cliccato!");

DoMethod(bottone, MUIM_Notify,
          MUIA_Pressed, FALSE,
          bottone,
          3,
          MUIM_Set,
          MUIA_Disabled,
          TRUE);


4.8.3 MUI: pericoli nell'uso degli attributi notificati
 
Nel paragrafo precedente abbiamo attuato delle notifiche con le quali 
abbiamo in un certo senso connesso tre classi tra di loro: 


Classe1-->Classe2-->Classe3

Tale connessione è di tipo univoco, poiché la notifica degli attributi 
avviene solo in un senso, e cioè da Classe1 sino a Classe3. Ci sono casi 
in cui potremmo avere bisogno di notificare allo stesso modo l'attributo 
MUIA_Classe1_Attr1 con gli eventuali cambiamenti avvenuti all'attributo 
MUIA_Classe3_Attr3. Per ottenere tutto questo dovremmo costituire una 
sorta di sincronizzazione dei valori, o meglio un collegamento biunivoco 
tra le classi. Tuttavia in una simile situazione e con gli strumenti 
finora esposti otterremo un loop nel sistema di notifica offerto da MUI, 
in quanto avremmo una situazione del genere: 


  -->Classe1-->Classe2-->Classe3--
  |                               |
  -------------Classe2<-----------

Per evitare una simile situazione dovremo intuitivamente interrompere in 
due parti il ciclo di notifica da noi creato: da un lato il cambiamento 
dell'attributo MUIA_Class1_Attr1 dovrà notificare fino alla Classe3 e 
fermarsi dopo aver settato MUIA_Class3_Attr3, d'altro canto l'eventuale 
cambiamento di MUIA_Class3_Attr3 dovrà propagarsi fino a giungere alla 
Classe1 e fermarsi nel momento in cui anche MUIA_Classe1_Attr1 assumerà 
lo stesso valore di MUIA_Classe3_Attr3. Per realizzare in codice quello che 
abbiamo espresso in modo intuitivo dovremo procedere come segue per la 
Classe3: 

DoMethod(obj, MUIM_Notify,
              MUIA_Classe3_Attr3, MUIV_EveryTime,
              istanza2,
              3,
              MUIM_Set,
              MUIA_Classe2_Attr2,
              MUIV_TriggerValue);

DoMethod(istanza2, MUIM_Notify,
           MUIA_Classe2_Attr2, MUIV_EveryTime,
           obj,
           3,
           MUIM_NoNotifySet,
           MUIA_Classe3_Attr3,
           MUIV_TriggerValue);

La prima chiamata a MUIM_Notify è di comprensione immediata: abbiamo in 
sostanza agganciato il cambiamento di MUIA_Classe3_Attr3 a 
MUIA_Classe2_Attr2, in altre parole stiamo propagando la nostra notifica
dalla Classe3 alla Classe2. La stessa cosa dovrà essere implementata nella
Classe2 in modo da propagare la notifica da essa alla Classe1.
Nella seconda chiamata a MUIM_Notify abbiamo invece utilizzato, al posto 
di MUIM_Set, MUIM_NoNotifySet. 
Il metodo MUIM_NoNotifySet esegue le stesse azioni di 
MUIM_Set, senza però notificare MUI dei cambiamenti che sta eseguendo 
sul valore di un determinato attributo. 
Abbiamo in altri termini effettuato la prima interruzione al nostro 
loop di notifiche. 
Bisogna adesso attuare la seconda interruzione, la quale sarà invece 
presente nella Classe2: 

DoMethod(obj,   MUIM_Notify,
                MUIA_Classe2_Attr2, MUIV_EveryTime,
                istanza1,
                3,
                MUIM_NoNotifySet,
                MUIA_Classe1_Attr1,
                MUIV_TriggerValue);


4.8.3.1 Pericoli con le catene di notifiche su Zune

MUI riconosce e gestisce opportunamente eventuali catene di notifiche.
In altre parole se consideriamo la situazione:

 -->MUIA_Classe1_Attr1 --> MUIA_Classe2_Attr2 --> MUIA_Classe3_Attr3--> MUIA_Classe4_Attr4-->
 |                                                                                          |
(#)                                                                                        (#)
 |                                                                                          |
 <--MUIA_Classe1_Attr1 <-- MUIA_Classe2_Attr2 <-- MUIA_Classe3_Attr3<-- MUIA_Classe4_Attr4<--
 
dove (#) rappresenta l'interruzione al loop con MUIM_NoNotify_Set, MUI
annulla automaticamente i "sottoloop" che potrebbero crearsi tra le
notifiche intermedie. Per intenderci, un sottoloop nella situazione su
esposta si potrebbe presentare in questo modo:

 -->MUIA_Classe2_Attr2 --> MUIA_Classe3_Attr-->
 |                                             |
 |                                             |
 <--MUIA_Classe2_Attr2 --> MUIA_Classe3_Attr<-- 
 
In tal caso MUI3.8+ riconosce il sottoloop e lo annulla, eliminando così
le possibili interazioni anomale, senza tuttavia interrompere la catena
delle notifiche innescata. 
Tutto ciò non vale però con Zune, il quale nelle ultime versioni riconosce
i sottoloop, ma non reagisce in modo pronto e risoluto come invece agisce MUI.
Per aggirare questo "bug" di Zune bisogna non solo interrompere il loop principale
con i due MUIM_NoNotifySet agli estremi del loop, ma è richiesto uno sdoppiamento
degli attributi utilizzati. In sostanza, ove possibile, è necessario assegnare
agli stessi attributi etichette differenti, nel nostro caso:

 -->MUIA_Classe1_Attr1 --> MUIA_Classe2_Attr2_X --> MUIA_Classe3_Attr3_X --> MUIA_Classe4_Attr4-->
 |                                                                                                |
(#)                                                                                              (#)
 |                                                                                                |
 <--MUIA_Classe1_Attr1 <-- MUIA_Classe2_Attr2_Y <-- MUIA_Classe3_Attr3_Y <-- MUIA_Classe4_Attr4<--
 
In cui MUIA_Classe2_Attr2_X è uguale a MUIA_Classe2_Attr2_Y e MUIA_Classe3_Attr3_X
è uguale a MUIA_Classe3_Attr3_Y.
In pratica bisognerà dichiarare etichette nuove che nei metodi OM_SET ed OM_GET 
corrisponderanno ad eseguire le stesse azioni delle etichette di cui 
rappresentano la copia.
Ovviamente questa soluzione funziona benissimo anche con MUI, dunque dovrebbe 
essere la scelta consigliata nel caso di applicazioni portabili.


4.9 MUI: sincronizzazioni, MUIM_Application_PushMethod e MUIM_Application_KillPushMethod

MUI garantisce che tutte le notifiche innescate durante un'iterazione del
ciclo di controllo eventi (vedi paragrafo 4.5.2) verranno eseguite 
all'interno della corrente iterazione. Ciò che tuttavia non viene garantito è 
l'ordine con il quale le notifiche verranno eseguite. In altri termini se
creiamo due o più catene di notifiche indipendenti, ad esempio:

Classe1_AttributoA --> Classe2_AttributoA --> Classe3_AttributoA  --> Classe4_AttributoA

e

Classe1_AttributoB --> Classe2_AttributoB --> Classe3_AttributoB  --> Classe4_AttributoB

MUI garantirà che Classe4_AttributoA e Classe4_AttributoB acquisiranno 
prima o poi il valore di Classe1_AttributoA e Classe1_AttributoB 
all'interno dell'iterazione n del ciclo di controllo eventi, ma non ci 
garantirà quale dei due attributi verrà configurato per primo e quale 
per ultimo. In altri termini per MUI scrivere:

SetAttrs(oggettoPippoClasse1, Classe1_AttributoA, valore1, TAG_DONE);
SetAttrs(oggettoPlutoClasse1, Classe1_AttributoB, valore2, TAG_DONE);

o scrivere:

SetAttrs(oggettoPlutoClasse1, Classe1_AttributoB, valore2, TAG_DONE);
SetAttrs(oggettoPippoClasse1, Classe1_AttributoA, valore1, TAG_DONE);

non ha alcuna rilevanza riguardo l'ordine con cui il sistema imposterà i
valori degli attributi Classe4_AttributoA e  Classe4_AttributoB. 
Tutto ciò è molto visibile nel caso di lunghe catene di notifiche in cui sono
coinvolti metodi da eseguire. Sebbene nel nostro codice le notifiche vengano 
innescate con un certo ordine logico, è possibile che non vengano 
eseguite nella maniera in cui le avevamo pensate. E' dunque molto 
importante non fare assunzioni sull'ordine di esecuzione dei nostri 
algoritmi nel momento in cui coinvolgiamo anche delle catene di 
notifiche.
Ad ogni modo è possibile mantenere un certo ordine di esecuzione anche
in casi di lunghe notifiche mediante l'uso di un metodo particolare, il
cui impiego principale non riguarda le notifiche: 
MUIM_Application_PushMethod.
MUIM_Application_PushMethod prende come argomento un metodo e i suoi 
parametri formali e lo incapsula dentro a un'area privata di memoria 
dell'oggetto MUIC_Application dal quale viene invocato. Il metodo 
incapsulato viene così mantenuto fino alla successiva iterazione del 
ciclo di controllo eventi, rallentando di fatto la sua esecuzione.
In altri termini, se consideriamo l'n-esima iterazione del ciclo di 
controllo eventi, possiamo scrivere:

LONG pushIDPippo = 0, pushIDPluto= 0;

pushIDPippo = DoMethod(oggettoApp, MUIM_Application_PushMethod, 
                        oggettoPippoClasse1, 
                        3, 
                        MUIM_Set, 
                        Classe1_AttributoA, 
                       valore1);

pushIDPluto = DoMethod(oggettoApp, MUIM_Application_PushMethod, 
                        oggettoPlutoClasse1, 
                        3, 
                        MUIM_Set, 
                        Classe1_AttributoB, 
                       valore2);

in questo modo l'impostazione dell'attributo Classe4_AttributoA verrà 
eseguita durante l'iterazione del ciclo di controllo n+1, mentre 
l'impostazione dell'attributo Classe4_AttributoB verrà eseguita durante 
l'iterazione n+2.
Dalla versione 3.9 di MUI MUIM_Application_PushMethod ritorna un valore
intero che identifica il metodo inserito all'interno dell'area di
memoria. Tale valore è utile nel caso in cui volessimo effettuare una
rimozione manuale (mirata) del metodo che è stato appena "pushato".

E' importante notare come l'area privata di memoria che abbiamo citato possa
venire esaurita facilmente se MUIM_Application_PushMethod venisse eseguito
molte volte prima della successiva iterazione del ciclo di controllo eventi. Quando
questo buffer si satura si protrebbe giungere a situazioni imprevedibili, fino
al punto di arrivare a crash di MUI. Esempi tipici sono la chiamata a 
MUIM_Application_PushMethod eseguita all'interno del metodo MUIM_Draw
della nostra sottoclasse, o molte chiamate a OM_SET per settare l'attributo 
considerato. In altre parole le situazioni
pericolose si presentano quando l'attributo da impostare assume un numero
alto di valori temporanei prima di raggiungere il valore finale che ci
interessa (immaginiamo ad esempio i diversi stati intermedi di un attributo
che indica la posizione di uno scroller). Per evitare tutto questo, e solo in
questi casi, è possibile impiegare un metodo non documentato di MUI
(supportato anche da Zune) la cui definizione è:

#define MUIM_Application_KillPushMethod 0x80429954       

Con la chiamata a MUIM_Application_KillPushMethod saremo noi a rimuovere
manualmente dal buffer i precedenti metodi archiviati per un determinato
oggetto. Da MUI3.9 come abbiamo accennato è possibile effettuare una rimozione
mirata, utilizzando a questo proposito il valore di ritorno della chiamata a
MUIM_Application_PushMethod. In caso di versioni precedenti MUI o Zune,
questo valore verrà ignorato e verrà rimosso l'ultimo metodo inserito nel
buffer (il metodo MUIM_Application_PushMethod su MUI3.8 e Zune ritorna TRUE se
il metodo agganciato a esso è stato aggiunto al buffer privato). Il nostro 
precedente codice diventerà quindi:

if (pushIDPippo)
{
    DoMethod(oggettoApp, MUIM_Application_KillPushMethod, 
              oggettoPippoClasse1, 
             pushIDPippo);

    pushIDPippo=0;
}

pushIDPippo = DoMethod(oggettoApp, MUIM_Application_PushMethod, 
                        oggettoPippoClasse1, 
                        3, 
                        MUIM_Set, 
                        Classe1_AttributoA, 
                       valore1);

if (pushIDPluto)
{
    DoMethod(oggettoApp, MUIM_Application_KillPushMethod, 
              oggettoPlutoClasse1, 
             pushIDPluto);

    pushIDPluto=0;
}

pushIDPluto = DoMethod(oggettoApp, MUIM_Application_PushMethod, 
                        oggettoPlutoClasse1, 
                        3, 
                        MUIM_Set, 
                        Classe1_AttributoB, 
                       valore2);

Naturalmente questo codice funziona anche nel caso di MUI3.9 e precedenti,
incluso Zune, in quanto i pushID nella definizione del messaggio delle
versioni precedenti di MUIM_Application_KillPushMethod prevedevano quel flag
pari a zero.


4.10 MUI: chiarimento sugli hook (metodi privati coinvolti in notifiche)

Finora abbiamo appreso come implementare metodi e attributi pubblici 
delle nostre classi, lasciando sottointeso il concetto di attributi e 
metodi privati. E' infatti evidente come metodi e attributi privati non 
siano altro che semplici funzioni e variabili utilizzati all'interno 
delle classi stesse. Come sappiamo lo standard BOOPSI identifica i 
metodi e gli attributi pubblici attraverso dei simboli da noi 
dichiarati, nei nostri esempi abbiamo citato simboli quali 
MUIM_MUIClassTutorial_ClickBut, MUIA_Classe1_Attr1 e cosi via. Abbiamo 
altresì visto i cosiddetti attributi notificabili, i quali non sono 
altro che attributi pubblici implementati seguendo delle regole 
specifiche, attraverso cui riescono ad avvisare eventualmente MUI di 
cambiamenti avvenuti ai loro valori. Tuttavia nel caso in cui dovessimo 
agganciare a una notifica un metodo privato (cioè una semplice funzione) 
apparentemente non avremmo modo di ottenere una simile associazione. In 
realtà abbiamo già esposto un meccanismo con il quale risolvere questa 
situazione: gli hook (4.5.1). Mediante un hook potremmo infatti dichiarare una 
funzione del tutto simile a un metodo pubblico, la quale secondo le 
regole BOOPSI non è però conosciuta all'esterno della classe. In altre 
parole, se usati correttamente, gli hook possono essere un potente 
strumento per aumentare l'incapsulamento di una classe, purché l'hook 
non sia accessibile dall'esterno della classe che lo implementa e 
utilizza. Nel nostro primo esempio, in cui avevamo un bottone e una 
stringa da legare attraverso una notifica agivamo all'interno della 
classe che dichiarava questi due oggetti e dunque l'implementazione 
della notifica mediante una funzione hook sarebbe stata la scelta 
migliore. Nel caso in cui invece dovessimo connettere due oggetti 
appartenenti a classi differenti dovremmo preferire un metodo pubblico o 
un attributo notificabile. 

Riassumendo abbiamo visto come una classe MUI può essere dotata di:

- Attributi privati : sono le variabili dichiarate dentro l'area dati della
                      classe che non sono state associate ad alcun simbolo; 

- Attributi pubblici    : sono variabili dichiarate (di solito) all'interno 
                          dell'area dati della classe, le quali sono associate in 
                          OM_NEW/OM_SET/OM_GET a dei simboli (per esempio MUIA_Classe1_Attr1); 

- Attributi notificabili: sono attributi pubblici il cui cambiamento di 
                          valore viene rilevato e/o modificato da MUI per mezzo 
                          di metodi quali MUIM_Notify e MUIM_Set; 

- Metodi privati        : sono le funzioni di utilità dichiarate, definite e 
                          utilizzate all'interno di una classe, ma non associate 
                          ad alcun simbolo; 

- Metodi privati 
  agganciabili a 
  notifiche             : sono funzioni associate a hook che vengono agganciate al 
                          cambiamento di valore di attributi notificabili attraverso 
                          i metodi MUIM_Notify e MUIM_CallHook; 

- Metodi pubblici       : sono funzioni dichiarate e definite che sono associate nel 
                          dispatcher di una classe a dei simboli (per esempio 
                          MUIM_MUIClassTutorial_ClickBut) e agganciate ad attributi 
                          notificabili attraverso MUIM_Notify; 
                                

4.11 Le macro shortcuts di MUI

In molte situazioni, rispettando del tutto il paradigma OOP ci si trova
tecnicamente in difficoltà, pensiamo ad esempio al già citato metodo
MUIM_Application_PushMethod. Tale metodo appartiene alla classe
MUIC_Application, ma in molti casi sarebbe utile poterlo utilizzare
anche all'interno di oggetti di nostre sottoclassi contenuti
all'interno di un'istanza di MUIC_Application, anche se in teoria
questi oggetti non potrebbero comunicare direttamente con tale istanza.
Per questa e tante altre situazioni, invece di passare indirizzi vitali
all'interno di sottoclassi che non dovrebbero conoscere certi aspetti
esterni, è possibile usare i cosiddetti shortcuts di MUI.
Tali shortcuts non hanno tuttavia validità in ogni situazione, dunque
bisogna usarli con cognizione e parsimonia, inoltre dal punto di vista
teorico andrebbero contro il paradigma OOP, quindi attenzione a non
creare pericoloso spaghetti code.  
Considerando il generico oggetto obj, tra gli shortcut MUI più usati ci
sono ad esempio:

_app(obj) = si riferisce all'istanza MUIC_Application che contiene il nostro obj;
_win(obj) = si riferisce all'istanza MUIC_Window che contiene il nostro obj;

In particolare questi due shortcut sono validi solo dopo che MUIM_Setup
è stato chiamato da MUI nella nostra sottoclasse e prima che
MUIM_Cleanup venga chiamato, dunque se per esempio venissero usati
all'interno di OM_NEW o OM_DISPOSE si otterrebbe un crash.
Sebbene l'utilizzo degli shortcuts MUI sia pensato per la creazione di
classi grafiche a basso livello (basta dare un'occhiata ai sorgenti
delle classi esterne MUI quali TextEditor MCC e simili), con l'utilizzo
di alcuni shortcut MUI come _app() e _win() si possono chiamare metodi
di classi esterne alla nostra sottoclasse senza fare salti mortali nel
codice.
Si consiglia di consultare l'header mui.h per conoscere tutti gli
shortcut MUI e quando sono validi.


