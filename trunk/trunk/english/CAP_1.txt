CHAPTER 1: Introduction

"There is a insurmountable problem. Which is not about the ego of someone or
the commercial and industrial projects. It's simply the litigiosity of the
community. We knows, amigans were always fractious like soccer supporters.
When they lived at home with mum who checked at what time they were back to home
and if they were studiyng, things went well. But when they become independent,
they made only messes."
Alfonso "alfie" Ranieri, ATML, 10/12/2007


1.1 Problems to face when programming on Amiga

There are multiple problems for a new Amiga programmer:

1) Lack of a good documentation;
2) Lack of modern tools for application development;


Most of the documentation on Amiga systems actually available is outdated,
mostly in English, and with a lot of obsolete parts. During this guide we will
address the reader to still valid resources in the world of the Amiga
reincarnations. In system such as Windows, MacOSX and Linux there are IDEs (Integrated 
Development Enviroment) with marvelous features, there programs give the users
everything they need to develop software in the simplest and fastest way possible.
Unfortunately the Amiga platform doesn't offer this anymore, except for an IDE,
CubicIDE, which offers a lot of features which are present in modern IDEs. By
the way, CubicIDE is a pay for use software (at this time, the user licence is
about 100 euros, an amount of money which is not always available to students
and beginners programmers...), and this software offers guaranteed support
only for AmigaOS3.x and MorphOS. So, there isn't any version for AROS.
In this guide we'll refer to possible alternatives in the little Amiga universe
concerning advanced editors. By the way, there is a big trouble above all of
these problems: the amiga mentality.


1.2 Past and modern philosophies: reset course

Amiga is born in the 80s, it amazed everyone for its features... If you still
don't know much about this, we suggest to read the story on www.amiga.it, just
to understand some good point about the Amiga platform. The user/programmer who
is starting a new software project have a valuable cultural and philosophical
background, which is the direct product of the trouble his beloved platform
went through. This means that some of its ideas should be perfectly shareable if
we were in the second half of the 80s, but are completely obsolete if applied
in the 21st century. In particolar, the amiga philosophies provide:

1) Lack of a definite design: the programmer starts to code without any
planning of what he's going to write;

2) Not reusing the available resources: they often develop a software which
offers 4 or 5 features identical to already available software. So they often
"reinvent the wheel" by not using already available APIs, but rewriting them
from scratch instead.

3) "Closed" source: the programmer writes the code considering himself as the
only developer able to carry on the project. This code is not written for
public release, it doesn't have any comprehensive documentation for who should
read the code in the future, there are poor comments and the order of function
writing is not always understandable;

4) Lack of collaboration: an Amiga program is often developed by a single coder,
it's very difficult too see two or more Amiga programmers collaborate on the
same software.

5) Lack of portability: the programmer believes that his own system will last
forever, it's the only valid system ("OS4 is better! No MOS is better!") and
will never change. For this reason the code is written in a coder's platform
dependent way. 

6) Focus on assembly optimizations: the lack of the design phase causes the
writing of code with non-robust algorythms and, in order to improve software
efficiency, the amiga developer prefers to use assembly language.

It's futile to repeat that the above conventions are (in almost all cases) 
wrong and bring to nothing good for the amiga platform. 21st century
software (those that are absent on amiga and that all users need) are
developed in this way instead:

1) Problem analysis and resolution: to develop a software, we first analyse
the problems it must solve. This analysis comprehends a series of phases
that will define the work to be done to develop the software without any
ambiguity.

2) Respect of quality rules: there are procedures and metrics to guarantee
the quality of some features of a software, for example reusability and maintainability
(= see point 6). Reusability means the reuse of functions and/or modules
already written, so the programmer doesn't need to reimplement such features
from scratch. This lead to lower production times and higher program
reliability, because third party modules are reused in other softwares too,
being tested and gaining beefiness.

3) "Open" code: code is written keeping in mind that it should be consulted
by someone who have no idea of what he's reading. This means that the code
have a huge documentation and plenty of comments inside the code itself. Code
is written always following the same order and considering a public release.

4) Using of more human resources to develop a software: groups of people can
collaborate to the same software. To obtain this code standards are defined
(such as how to indent code, how to insert comments etc...), and code sharing
tools, such as svn, are used.

5) Portability: it's useless to definte the portability meaning, just
see projects such as Firefox and Openoffice, or independent programming
language such as Java;

6) Maintenance: it's a microanalysis phase, in which we try to maintain
"alive" the software we developed. In this phase, we can fix bugs (corrective
maintenance), add new features (adaptive maintenance) and optimize some
parts of the software (perfective maintenance). This phase derives directly
from the above points, because a maintenance process can require a huge
resources expense if the software wasn't well thought or the code wasn't
well written, sometimes this leads to the dismissal of the software itself.


1.3 What is the Amiga platfrom today? Hints to code portability...

This chapter should appear difficult to who has never used Amiga or has
never developed with it's APIs. Reader's doubts should disappear following
this guide, so don't worry if you'll not understand something initially.

What is the Amiga platfrom? We have to summarize in a single sentence more
than twenty years of Amiga history, so we'll be concise: today, the Amiga
platform is the combination of four operating systems seemingly independent,
whose longevity is intrinsically connected. We refer to the following operating
systems:

- AmigaOS3.x: http://it.wikipedia.org/wiki/AmigaOS#AmigaOS3.x 
- AmigaOS4: http://it.wikipedia.org/wiki/AmigaOS#AmigaOS4.x 
- MorphOS: http://it.wikipedia.org/wiki/MorphOS 
- AROS: http://it.wikipedia.org/wiki/AROS 

Due to the conditions in which those Amiga flavours live, (AmigaOS3.x is no
more developed since 2000, AmigaOS4 is under legal troubles, MorphOS
development is discontinuous, AROS is incline to anarchy), we must think
about the reasons we want to develop something only for one of those
amiga flavours, while we could do it for all of them. If our goal is to
write software for the Amiga platform and the platform is the result of
the combination of these four incarnations, we shouldn't exclude none of
them. Every incarnation could prevail on the others for some reason and
our software couldn't have some system to run on, in other words, our
software could absurdly became a non Amiga software. The chance to run
on more than one amiga flavour makes the software more complete: more
support for different platforms brings to a larger user base and, therefore,
more feedback and testing on its features. This brings a growth of
robustness, reliability, completeness and efficiency on the program being
developed... Writing "Amiga multiplatform" code is not difficult as it should
appear, but we must follow some tips:

1) MUI: 
	http://aminet.net/dev/mui/mui38dev.lha ; 
	http://www.amigamagazine.info/am_73.html (Transaction) ; 

	First of all the choice of an API to build a modern graphic interface
	(in which we don't need to reimplement basilar gadgets from scratch or
	to define politics for element placements - Layout - or to struggle to
	understand how to "interconnect" graphical objects) must be MUI, or
	Magic User Interface, instead that on other solutions. The MUI API are
	available for all Amiga flavours, this thing makes MUI a must.

2) SDI: 
	http://sourceforge.net/projects/sditools/ ; 
	
	Every amiga reincarnations have extended the AmigaOS3.1 APIs in different ways.
	So, in every reincarnation there is a common API group, an updated and
	incompatible API group and some new APIs incompatible and probably absent
	from an incarnation to another. Regarding the second point, some AmigaOS 3.x
	peculiarities, such as BOOPSI classes' dispatcher implementation, the callback
	hook system etc... are different from an incarnation to another. To write
	compatible software some macros are available, they are called SDI tools.
	Using SDI we can write libraries and other vital parts of our software in a
	portable way, without knowing how a single thing was reimplemented in AROS or
	in AmigaOS4, but only knowing the common parts.


3) Isolated conditional code:

	We've just realized that there are new features in every amiga reincarnation which
	could be absent in the others. If you want to use these new APIs we suggest to
	use conditional code (in C language such code is marked between the following
	instruction: #ifdef,#elif,#else,#endif), inside the vital functions of the
	software, or to isolate such parts in functions and/or separate files to include
	in the compilation only for an incarnation instead that another.

In the open source and freely readable amiga software we can find Yam, SimpleMail,
Scout, and the MUI classes TextEditor, BetterString, NListxxx. All of these programs,
used by all Amiga users, are developed keeping in mind the above three points.
